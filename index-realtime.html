<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D/s Dynamic Contract - Real-time Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-dark: #8b0000;
            --primary-light: #dc143c;
            --accent-pink: #ff69b4;
            --accent-light-pink: #ffb6c1;
            --background: #1a0000;
            --text-light: #fff5f5;
            --border-accent: #ff1493;
            --app-header-height: 70px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', serif;
            background: var(--background);
            color: var(--text-light);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Authentication Screen */
        #auth-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, var(--primary-dark) 0%, #000 100%);
        }

        .auth-container {
            background: rgba(139, 0, 0, 0.3);
            border: 2px solid var(--border-accent);
            border-radius: 15px;
            padding: 40px;
            max-width: 450px;
            width: 90%;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .auth-container h1 {
            font-family: 'Cinzel', serif;
            text-align: center;
            color: var(--accent-pink);
            margin-bottom: 10px;
            font-size: 2em;
        }

        .auth-container .subtitle {
            text-align: center;
            color: var(--accent-light-pink);
            margin-bottom: 30px;
            font-style: italic;
        }

        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--primary-light);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.3s;
        }

        .auth-tab.active {
            background: var(--primary-light);
            border-color: var(--border-accent);
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.5);
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--accent-pink);
            font-weight: 600;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--primary-light);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Crimson Text', serif;
            font-size: 16px;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-pink);
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.3);
        }

        .auth-button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--accent-pink) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .auth-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.5);
        }

        .auth-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error-message {
            background: rgba(220, 20, 60, 0.2);
            border: 1px solid var(--primary-light);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            color: var(--accent-light-pink);
            display: none;
        }

        .success-message {
            background: rgba(0, 128, 0, 0.2);
            border: 1px solid #00ff00;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            color: #90ee90;
            display: none;
        }

        /* Main App Screen */
        #app-screen {
            display: none;
        }

        /* Header - Modern Redesign */
        .app-header {
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary-light) 100%);
            padding: 18px 30px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.6);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .app-header h1 {
            font-family: 'Cinzel', serif;
            color: var(--accent-pink);
            font-size: 1.6em;
            margin: 0;
            white-space: nowrap;
        }

        /* Presence Section in Header */
        .header-presence-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            position: relative;
        }

        .presence-badge {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: 25px;
            border: 1px solid rgba(255, 105, 180, 0.3);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }

        .presence-badge:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: var(--accent-pink);
            box-shadow: 0 4px 12px rgba(255, 105, 180, 0.2);
        }

        .presence-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff00;
            animation: pulse 2s infinite;
            box-shadow: 0 0 8px #00ff00;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }

        .presence-count {
            font-weight: 600;
            color: var(--accent-pink);
        }

        /* Presence Dropdown */
        .presence-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(20, 10, 10, 0.98), rgba(30, 15, 15, 0.98));
            border: 2px solid var(--accent-pink);
            border-radius: 12px;
            padding: 15px;
            min-width: 280px;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .presence-dropdown.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .presence-dropdown-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--accent-pink);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 105, 180, 0.2);
        }

        .presence-user-item {
            padding: 10px;
            margin: 6px 0;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border-left: 3px solid;
            transition: all 0.2s;
        }

        .presence-user-item:hover {
            background: rgba(0, 0, 0, 0.6);
        }

        .presence-user-item.editing {
            border-left-color: #ff6b9d;
        }

        .presence-user-item.viewing {
            border-left-color: #d4768f;
        }

        .presence-user-name {
            color: #ffb6c1;
            font-weight: 500;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .presence-user-name.you {
            font-weight: 700;
        }

        .presence-user-mode {
            font-size: 11px;
            margin-top: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .presence-user-mode.editing {
            color: #ff6b9d;
        }

        .presence-user-mode.viewing {
            color: #d4768f;
        }

        .multi-editor-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #dc143c, #ff1744);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: gentlePulse 2s infinite;
        }

        @keyframes gentlePulse {
            0%, 100% { box-shadow: 0 0 0 rgba(220, 20, 60, 0.4); }
            50% { box-shadow: 0 0 12px rgba(220, 20, 60, 0.6); }
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
        }

        .header-controls .btn {
            white-space: nowrap;
        }

        .btn {
            padding: 10px 18px;
            background: var(--primary-light);
            border: 1px solid var(--border-accent);
            border-radius: 10px;
            color: white;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            background: var(--accent-pink);
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(255, 105, 180, 0.4);
            border-color: var(--accent-pink);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(255, 105, 180, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 105, 180, 0.15);
            border-color: rgba(255, 105, 180, 0.4);
        }

        .btn-secondary:hover {
            background: rgba(255, 105, 180, 0.3);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn-icon {
            padding: 10px 14px;
        }

        /* Contract List */
        .contract-list-screen {
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
        }

        .contract-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .contract-list-header h2 {
            font-family: 'Cinzel', serif;
            color: var(--accent-pink);
            font-size: 2em;
        }

        .contracts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .contract-card {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.3) 100%);
            border: 2px solid var(--primary-light);
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .contract-card:hover {
            border-color: var(--accent-pink);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 105, 180, 0.3);
        }

        .contract-card h3 {
            font-family: 'Cinzel', serif;
            color: var(--accent-pink);
            margin-bottom: 10px;
        }

        .contract-card .meta {
            color: var(--accent-light-pink);
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .contract-card .actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .contract-card .btn {
            flex: 1;
            padding: 8px;
            font-size: 12px;
        }

        .shared-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--accent-pink);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
        }

        /* Contract Editor */
        .contract-editor {
            display: none;
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
        }

        .editor-header {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            margin-bottom: 25px;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 105, 180, 0.2);
            position: sticky;
            top: calc(var(--app-header-height) - 1px);
            z-index: 90;
            transition: box-shadow 0.3s, background 0.3s, border-color 0.3s;
        }

        .editor-header.scrolled {
            background: rgba(0, 0, 0, 0.95);
            border-color: rgba(255, 105, 180, 0.4);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 105, 180, 0.3);
        }

        .editor-title {
            min-width: 0;
        }

        .editor-title > input {
            width: 100%;
            max-width: 600px;
            padding: 14px 18px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--primary-light);
            border-radius: 10px;
            color: var(--accent-pink);
            font-family: 'Cinzel', serif;
            font-size: 1.4em;
            font-weight: 700;
            transition: all 0.3s;
        }

        .editor-title > input:focus {
            outline: none;
            border-color: var(--accent-pink);
            box-shadow: 0 0 0 3px rgba(255, 105, 180, 0.1);
        }

        .editor-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        /* Contract Content Area */
        .contract-content-area {
            position: relative;
            background:
                linear-gradient(135deg, rgba(20, 10, 10, 0.95), rgba(30, 15, 15, 0.98)),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(139, 0, 0, 0.02) 2px,
                    rgba(139, 0, 0, 0.02) 4px
                );
            border: 3px solid #8b0000;
            border-radius: 5px;
            padding: 60px;
            margin-top: 20px;
            box-shadow:
                0 0 0 1px rgba(255, 105, 180, 0.3),
                0 0 30px rgba(139, 0, 0, 0.6),
                inset 0 0 100px rgba(0, 0, 0, 0.8);
        }

        /* Leather texture overlay */
        .contract-content-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 1px,
                rgba(0, 0, 0, 0.03) 1px,
                rgba(0, 0, 0, 0.03) 2px
            );
            pointer-events: none;
            border-radius: 5px;
        }

        /* Corner bows */
        .content-bow {
            position: absolute;
            font-size: 35px;
            filter: drop-shadow(0 0 10px rgba(255, 105, 180, 0.8));
            z-index: 10;
        }

        .bow-top-left {
            top: -15px;
            left: -15px;
            transform: rotate(-15deg);
        }

        .bow-top-right {
            top: -15px;
            right: -15px;
            transform: rotate(15deg);
        }

        .bow-bottom-left {
            bottom: -15px;
            left: -15px;
            transform: rotate(-15deg);
        }

        .bow-bottom-right {
            bottom: -15px;
            right: -15px;
            transform: rotate(15deg);
        }

        /* Contract Header */
        .contract-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 2px solid rgba(139, 0, 0, 0.6);
            position: relative;
            z-index: 1;
        }

        .contract-header::after {
            content: '⛓️ 🎀 ⛓️';
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            background: linear-gradient(135deg, rgba(20, 10, 10, 0.95), rgba(30, 15, 15, 0.98));
            padding: 0 20px;
        }

        .contract-display-title {
            font-family: 'Cinzel', serif;
            font-size: 44px;
            font-weight: 700;
            background: linear-gradient(135deg, #8b0000, #ff69b4, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 30px rgba(255, 105, 180, 0.3);
        }

        .contract-subtitle {
            text-align: center;
            font-size: 16px;
            color: var(--dusty-pink);
            font-style: italic;
            margin-top: 15px;
            font-family: 'Crimson Text', serif;
        }

        .inline-name-input {
            border: none;
            border-bottom: 1px solid rgba(139, 0, 0, 0.6);
            background: rgba(255, 255, 255, 0.03);
            font-family: 'Crimson Text', serif;
            font-size: 16px;
            font-style: italic;
            color: var(--pink-text);
            text-align: center;
            padding: 5px 12px;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .inline-name-input:focus {
            outline: none;
            border-bottom-color: var(--accent-pink);
            background: rgba(255, 255, 255, 0.05);
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.2);
        }

        .inline-name-input::placeholder {
            color: rgba(212, 118, 143, 0.5);
        }

        .editor-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .sync-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 1px solid var(--accent-pink);
            font-size: 0.9em;
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff00;
        }

        .sync-dot.syncing {
            background: #ffff00;
            animation: pulse 1s infinite;
        }

        .sync-dot.error {
            background: #ff0000;
        }

        /* Contract Sections */
        .contract-section {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.2) 0%, rgba(0, 0, 0, 0.2) 100%);
            border: 2px solid var(--primary-light);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--accent-pink);
            padding-bottom: 15px;
        }

        .section-header h2 {
            font-family: 'Cinzel', serif;
            color: var(--accent-pink);
            font-size: 1.8em;
        }

        .section-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .section-content {
            display: grid;
            gap: 20px;
        }

        /* Form Fields */
        .field-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .field-group label {
            color: var(--accent-pink);
            font-weight: 600;
            font-size: 1.1em;
        }

        .field-group input,
        .field-group textarea,
        .field-group select {
            padding: 12px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--primary-light);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Crimson Text', serif;
            font-size: 16px;
        }

        .field-group input:focus,
        .field-group textarea:focus,
        .field-group select:focus {
            outline: none;
            border-color: var(--accent-pink);
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.3);
        }

        .field-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        /* List Items */
        .list-item {
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--primary-light);
            transition: all 0.3s;
        }

        .list-item:hover {
            border-color: var(--accent-pink);
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.2);
        }

        .list-item.dragging {
            opacity: 0.5;
            cursor: move;
        }

        .drag-handle {
            cursor: grab;
            color: var(--accent-pink);
            font-size: 20px;
            margin-right: 8px;
            user-select: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
            background: rgba(255, 105, 180, 0.15);
            border: 2px solid rgba(255, 105, 180, 0.3);
            border-radius: 6px;
            padding: 4px 6px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .drag-handle:hover {
            background: rgba(255, 105, 180, 0.25);
            border-color: rgba(255, 105, 180, 0.5);
            box-shadow: 0 2px 5px rgba(255, 105, 180, 0.3);
            transform: scale(1.05);
        }

        .drag-handle:active {
            cursor: grabbing;
            background: rgba(255, 105, 180, 0.35);
            border-color: var(--accent-pink);
            transform: scale(0.98);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .field-group {
            position: relative;
            padding-left: 10px;
            margin-left: 45px;
        }

        /* List fields don't have parent bow, so no left padding */
        .field-group-list {
            padding-left: 0;
            margin-left: 0;
        }

        .field-group .drag-handle {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
        }

        .field-group .drag-handle:hover {
            transform: translateY(-50%) scale(1.05);
        }

        .field-group .drag-handle:active {
            transform: translateY(-50%) scale(0.98);
        }

        .field-group.dragging {
            opacity: 0.5;
            background: rgba(255, 105, 180, 0.1);
        }

        .list-item {
            position: relative;
            padding-left: 10px;
            margin-left: 45px;
        }

        .list-item .drag-handle {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
        }

        .list-item .drag-handle:hover {
            transform: translateY(-50%) scale(1.05);
        }

        .list-item .drag-handle:active {
            transform: translateY(-50%) scale(0.98);
        }

        .list-item.dragging {
            opacity: 0.5;
            background: rgba(255, 105, 180, 0.1);
        }

        .list-item input,
        .list-item textarea {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--primary-light);
            border-radius: 6px;
            padding: 10px;
            color: var(--text-light);
            font-family: 'Crimson Text', serif;
        }

        .remove-btn {
            background: rgba(220, 20, 60, 0.3);
            border: 1px solid var(--primary-light);
            color: var(--accent-light-pink);
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
            font-family: 'Cinzel', serif;
            white-space: nowrap;
            min-height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .remove-btn:hover {
            background: var(--primary-light);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(220, 20, 60, 0.4);
        }

        .add-item-btn {
            margin-top: 12px;
            padding: 12px 18px;
            background: rgba(255, 105, 180, 0.15);
            border: 2px dashed var(--accent-pink);
            border-radius: 10px;
            color: var(--accent-pink);
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            font-size: 13px;
            font-weight: 500;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .add-item-btn:hover {
            background: rgba(255, 105, 180, 0.3);
            border-style: solid;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
        }

        /* History Panel */
        .history-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background: linear-gradient(135deg, var(--primary-dark) 0%, #000 100%);
            border-left: 2px solid var(--border-accent);
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.7);
            transition: right 0.3s;
            z-index: 1000;
            overflow-y: auto;
        }

        .history-panel.open {
            right: 0;
        }

        .history-header {
            padding: 20px;
            background: rgba(139, 0, 0, 0.3);
            border-bottom: 2px solid var(--accent-pink);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-header h3 {
            font-family: 'Cinzel', serif;
            color: var(--accent-pink);
        }

        .history-timeline {
            padding: 20px;
        }

        .history-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--primary-light);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .history-item::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 20px;
            width: 10px;
            height: 10px;
            background: var(--accent-pink);
            border-radius: 50%;
        }

        .history-item .timestamp {
            color: var(--accent-light-pink);
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .history-item .change {
            color: var(--text-light);
        }

        .history-item .user {
            color: var(--accent-pink);
            font-weight: 600;
        }

        .history-date-group {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(220, 20, 60, 0.95));
            padding: 8px 15px;
            margin: 0 -20px 15px -20px;
            border-bottom: 1px solid var(--accent-pink);
            font-weight: 600;
            color: white;
            font-size: 0.9em;
            z-index: 10;
            cursor: pointer;
            user-select: none;
        }

        .history-date-group:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 1), rgba(220, 20, 60, 1));
        }

        .history-date-group .toggle-icon {
            float: right;
            transition: transform 0.3s;
        }

        .history-date-group.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .history-group-items.collapsed {
            display: none;
        }

        /* Undo/Redo Controls */
        .undo-redo-group {
            display: flex;
            gap: 5px;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 8px;
            border: 1px solid rgba(255, 105, 180, 0.2);
        }

        .undo-redo-btn {
            padding: 8px 12px;
            background: rgba(255, 105, 180, 0.1);
            border: 1px solid rgba(255, 105, 180, 0.3);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .undo-redo-btn:hover:not(:disabled) {
            background: rgba(255, 105, 180, 0.25);
            border-color: var(--accent-pink);
            transform: translateY(-1px);
        }

        .undo-redo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .undo-redo-btn .shortcut-hint {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: var(--accent-light-pink);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .undo-redo-btn:hover .shortcut-hint {
            opacity: 1;
        }

        /* Undo History Dropdown */
        .undo-history-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            background: linear-gradient(135deg, rgba(20, 10, 10, 0.98), rgba(30, 15, 15, 0.98));
            border: 2px solid var(--accent-pink);
            border-radius: 8px;
            padding: 10px;
            min-width: 280px;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1001;
            backdrop-filter: blur(10px);
        }

        .undo-history-dropdown.show {
            display: block;
            animation: slideDown 0.2s ease-out;
        }

        .undo-history-header {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent-pink);
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 105, 180, 0.2);
        }

        .undo-history-item {
            padding: 8px 10px;
            margin: 4px 0;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border-left: 3px solid var(--accent-pink);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        .undo-history-item:hover {
            background: rgba(255, 105, 180, 0.2);
            transform: translateX(3px);
        }

        .undo-history-item.current {
            background: rgba(255, 105, 180, 0.3);
            border-left-color: #00ff00;
            font-weight: 600;
        }

        .undo-history-item .action-desc {
            color: var(--text-light);
            margin-bottom: 3px;
        }

        .undo-history-item .action-time {
            color: var(--accent-light-pink);
            font-size: 11px;
        }

        /* Share Dialog */
        .dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .dialog-overlay.open {
            display: flex;
        }

        .dialog {
            background: linear-gradient(135deg, var(--primary-dark) 0%, #000 100%);
            border: 2px solid var(--border-accent);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .dialog h3 {
            font-family: 'Cinzel', serif;
            color: var(--accent-pink);
            margin-bottom: 20px;
        }

        .dialog-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .dialog-actions .btn {
            flex: 1;
        }

        /* Responsive Design - Mobile First Approach */

        /* Small Phones */
        @media (max-width: 480px) {
            .auth-container {
                padding: 20px 15px;
                border-radius: 10px;
                width: 95%;
            }

            .auth-container h1 {
                font-size: 1.4em;
            }

            .btn {
                padding: 11px 14px;
                font-size: 13px;
                min-height: 44px;
                white-space: nowrap;
            }

            /* Fixed Mobile Header - No Grid Overlap */
            .app-header {
                display: flex;
                flex-direction: column;
                padding: 12px;
                gap: 10px;
                align-items: stretch;
            }

            .app-header h1 {
                font-size: 1.2em;
                text-align: center;
                margin: 0;
                padding: 5px 0;
            }

            .header-presence-section {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                width: 100%;
                gap: 8px;
                padding: 0;
            }

            .presence-badge {
                font-size: 11px;
                padding: 6px 12px;
                white-space: nowrap;
            }

            .multi-editor-badge {
                font-size: 10px;
                padding: 4px 8px;
                white-space: nowrap;
            }

            .presence-dropdown {
                left: 5px;
                right: 5px;
                transform: none;
                max-width: none;
                width: auto;
            }

            .header-controls {
                display: grid;
                grid-template-columns: 1fr 1fr;
                width: 100%;
                gap: 6px;
                margin: 0;
            }

            .header-controls .btn {
                padding: 10px 8px;
                font-size: 11px;
                min-height: 44px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            #user-menu-btn {
                grid-column: 1 / 2;
            }

            #settings-btn {
                grid-column: 2 / 3;
            }

            #logout-btn {
                grid-column: 1 / -1;
            }

            #user-email {
                max-width: 70px;
                overflow: hidden;
                text-overflow: ellipsis;
                display: inline-block;
            }

            .contract-list-screen {
                margin: 15px 0;
                padding: 12px;
            }

            .contract-list-header {
                flex-direction: column;
                gap: 12px;
                margin-bottom: 20px;
            }

            .contract-list-header h2 {
                font-size: 1.4em;
                text-align: center;
                margin: 0;
            }

            .contract-list-header .btn {
                width: 100%;
                max-width: none;
            }

            .contracts-grid {
                grid-template-columns: 1fr;
                gap: 12px;
                padding: 0;
            }

            .contract-card {
                padding: 15px;
                margin: 0;
            }

            .contract-editor {
                margin: 0;
                padding: 0;
            }

            .editor-header {
                display: flex;
                flex-direction: column;
                padding: 12px;
                gap: 10px;
                margin-bottom: 15px;
                position: sticky;
                top: calc(var(--app-header-height) - 1px);
                z-index: 90;
                border-radius: 8px;
            }

            .editor-title {
                width: 100%;
            }

            .editor-title input {
                width: 100%;
                max-width: 100%;
                font-size: 1.1em;
                padding: 12px;
            }

            .editor-actions {
                display: grid;
                grid-template-columns: 1fr 1fr;
                width: 100%;
                gap: 6px;
            }

            .editor-actions .btn {
                padding: 10px 8px;
                font-size: 11px;
                min-height: 44px;
                white-space: nowrap;
            }

            .editor-actions .sync-status {
                grid-column: 1 / -1;
                justify-self: center;
                margin-bottom: 5px;
            }

            #back-to-list-btn {
                grid-column: 1 / -1;
            }

            .contract-content-area {
                padding: 20px 12px;
                border-width: 2px;
                margin: 0 10px;
            }

            .history-panel {
                width: 100%;
                right: -100%;
            }

            .history-panel .btn {
                padding: 10px 14px;
                font-size: 13px;
            }

            .section {
                padding: 20px 12px;
            }

            .section-header {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .section h2 {
                font-size: 1.4em;
                margin-bottom: 0;
            }

            .section-actions {
                flex-direction: column;
                gap: 8px;
                margin-top: 0;
            }

            .section-actions .btn {
                width: 100%;
                padding: 11px 14px;
                font-size: 12px;
            }

            .field-group {
                padding-left: 0;
                gap: 10px;
            }

            .field-group label {
                font-size: 14px;
            }

            .field-group input,
            .field-group textarea,
            .field-group select {
                font-size: 15px;
                padding: 12px;
            }

            .drag-handle {
                font-size: 16px;
                margin-right: 0;
                padding: 3px 4px;
                border-width: 1.5px;
            }

            .field-group {
                padding-left: 10px;
                margin-left: 35px;
            }

            .field-group-list {
                margin-left: 0;
                padding-left: 0;
            }

            .list-item {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
                padding-left: 10px;
                margin-left: 35px;
            }

            .field-group .drag-handle,
            .list-item .drag-handle {
                left: -32px;
            }

            .field-group .drag-handle:hover,
            .list-item .drag-handle:hover {
                transform: translateY(-50%) scale(1.02);
            }

            .list-item input {
                width: 100%;
            }

            .remove-btn {
                width: 100%;
                padding: 10px 12px;
                font-size: 11px;
                margin-top: 8px;
            }

            .add-item-btn {
                margin-top: 10px;
                padding: 11px 14px;
                font-size: 12px;
                min-height: 44px;
            }

            .form-group label {
                font-size: 14px;
            }

            .form-group input,
            .form-group textarea {
                font-size: 15px;
                padding: 12px;
            }

            .dialog {
                padding: 20px;
                max-width: 95%;
            }

            .dialog h3 {
                font-size: 1.3em;
            }

            /* Preview Mode - Mobile */
            .preview-header {
                padding: 12px;
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .preview-header h3 {
                text-align: center;
                font-size: 1.1em;
                margin: 0;
            }

            .preview-actions {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 6px;
                width: 100%;
            }

            .preview-actions .btn {
                padding: 10px 8px;
                font-size: 11px;
            }

            #close-preview-btn {
                grid-column: 1 / -1;
            }

            .preview-container {
                padding: 20px 12px;
                margin: 10px;
                border-width: 2px;
            }

            .preview-content {
                margin-top: 0;
            }

            .preview-container h1 {
                font-size: 1.6em;
            }

            .preview-container h2 {
                font-size: 1.2em;
            }

            .preview-bow {
                font-size: 35px;
            }
        }

        /* Phones and Large Phones */
        @media (min-width: 481px) and (max-width: 767px) {
            .auth-container {
                padding: 30px;
            }

            .btn {
                min-height: 44px;
            }

            .app-header {
                display: flex;
                flex-direction: column;
                padding: 15px 18px;
                gap: 12px;
            }

            .app-header h1 {
                font-size: 1.4em;
                text-align: center;
                margin: 0;
            }

            .header-presence-section {
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
            }

            .presence-dropdown {
                left: 15px;
                right: 15px;
                transform: none;
                max-width: none;
            }

            .header-controls {
                display: flex;
                width: 100%;
                justify-content: center;
                gap: 8px;
                flex-wrap: wrap;
            }

            .header-controls .btn {
                flex: 1 1 auto;
                min-width: 110px;
                max-width: 200px;
            }

            .contract-list-screen {
                margin: 20px 0;
                padding: 18px;
            }

            .contract-list-header {
                flex-direction: column;
                gap: 15px;
            }

            .contract-list-header .btn {
                width: 100%;
                max-width: 350px;
                margin: 0 auto;
            }

            .contracts-grid {
                grid-template-columns: 1fr;
                gap: 18px;
            }

            .contract-editor {
                margin: 0;
                padding: 15px;
            }

            .editor-header {
                display: flex;
                flex-direction: column;
                padding: 16px;
                gap: 12px;
            }

            .editor-title input {
                max-width: 100%;
                width: 100%;
            }

            .editor-actions {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                width: 100%;
                gap: 8px;
            }

            .editor-actions .btn {
                padding: 11px 12px;
                font-size: 12px;
            }

            .editor-actions .sync-status {
                grid-column: 1 / -1;
                justify-self: center;
            }

            #back-to-list-btn {
                grid-column: 1 / -1;
            }

            .contract-content-area {
                padding: 25px 15px;
                margin: 0 10px;
            }

            .section {
                padding: 18px 12px;
            }

            .section-header {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .section h2 {
                font-size: 1.5em;
                margin-bottom: 0;
            }

            .section-actions {
                flex-direction: column;
                gap: 8px;
                margin-top: 0;
            }

            .section-actions .btn {
                width: 100%;
                padding: 10px 12px;
                font-size: 12px;
            }

            .drag-handle {
                font-size: 17px;
                padding: 3px 5px;
            }

            .field-group {
                padding-left: 10px;
                margin-left: 37px;
            }

            .field-group-list {
                margin-left: 0;
                padding-left: 0;
            }

            .list-item {
                flex-wrap: wrap;
                padding: 15px;
                padding-left: 10px;
                margin-left: 37px;
            }

            .field-group .drag-handle,
            .list-item .drag-handle {
                left: -34px;
            }

            .list-item input {
                flex: 1;
                min-width: 200px;
            }

            .remove-btn {
                padding: 9px 12px;
                font-size: 11px;
            }

            .add-item-btn {
                padding: 11px 16px;
                font-size: 12px;
            }

            .history-panel {
                width: 100%;
                right: -100%;
            }

            /* Preview Mode - Phones */
            .preview-header {
                padding: 15px;
                flex-direction: column;
                gap: 12px;
            }

            .preview-header h3 {
                text-align: center;
                font-size: 1.2em;
            }

            .preview-actions {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .preview-actions .btn {
                flex: 1 1 calc(50% - 4px);
                min-width: 120px;
            }

            .preview-container {
                padding: 30px 20px;
                margin: 15px;
            }

            .preview-content {
                margin-top: 0;
            }
        }

        /* Tablets */
        @media (min-width: 768px) and (max-width: 1023px) {
            .app-header {
                display: grid;
                grid-template-columns: 1fr auto;
                gap: 15px;
                padding: 16px 20px;
            }

            .app-header h1 {
                font-size: 1.5em;
                grid-column: 1 / -1;
                text-align: center;
            }

            .header-presence-section {
                grid-column: 1 / -1;
                justify-content: center;
            }

            .header-controls {
                grid-column: 1 / -1;
                justify-content: center;
                flex-wrap: wrap;
                gap: 10px;
            }

            .contract-list-screen {
                padding: 25px;
            }

            .contracts-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
            }

            .contract-card {
                padding: 20px;
            }

            .contract-editor {
                padding: 25px;
            }

            .editor-header {
                padding: 18px;
                gap: 15px;
            }

            .editor-title input {
                font-size: 1.3em;
            }

            .editor-actions {
                gap: 10px;
            }

            .contract-content-area {
                padding: 50px 40px;
            }

            .history-panel {
                width: 350px;
                right: -350px;
            }

            .section {
                padding: 30px 25px;
            }

            .section-header {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .section h2 {
                font-size: 1.8em;
                margin-bottom: 0;
            }

            .section-actions {
                flex-direction: column;
                gap: 10px;
                margin-top: 0;
            }

            .section-actions .btn {
                width: 100%;
            }

            .drag-handle {
                font-size: 18px;
                padding: 3px 5px;
            }

            .field-group {
                padding-left: 10px;
                margin-left: 40px;
            }

            .field-group-list {
                margin-left: 0;
                padding-left: 0;
            }

            .list-item {
                flex-wrap: nowrap;
                padding: 15px;
                padding-left: 10px;
                margin-left: 40px;
            }

            .field-group .drag-handle,
            .list-item .drag-handle {
                left: -36px;
            }

            .remove-btn {
                padding: 9px 14px;
                font-size: 12px;
            }

            .add-item-btn {
                padding: 12px 18px;
                font-size: 13px;
            }

            /* Preview Mode - Tablets */
            .preview-header {
                padding: 16px 20px;
            }

            .preview-container {
                padding: 50px 40px;
                margin: 20px;
            }

            .preview-container h1 {
                font-size: 2.5em;
            }

            .preview-content {
                margin-top: 0;
            }
        }

        /* Touch Device Improvements - All Mobile/Tablet */
        @media (max-width: 1023px) {
            /* Larger touch targets */
            button,
            .btn,
            input[type="button"],
            input[type="submit"] {
                min-height: 44px;
                min-width: 44px;
            }

            /* Add/Remove button touch improvements */
            .add-item-btn {
                min-height: 44px;
                font-size: 13px;
            }

            .remove-btn {
                min-height: 40px;
                min-width: 40px;
                touch-action: manipulation;
            }

            /* Section actions touch friendly */
            .section-actions {
                margin-top: 15px;
            }

            .section-actions .btn {
                min-height: 44px;
                touch-action: manipulation;
            }

            /* Better spacing for form elements */
            .form-group {
                margin-bottom: 18px;
            }

            .field-group {
                margin-bottom: 15px;
            }

            /* List items touch friendly */
            .list-item {
                padding: 14px;
                padding-left: 10px;
                margin-left: 37px; /* Preserve space for drag handle */
                margin-bottom: 12px;
            }

            .list-item input {
                min-height: 44px;
                font-size: 16px;
            }

            /* Drag handle touch friendly - increase tap area without affecting layout */
            .drag-handle {
                touch-action: none;
            }

            .drag-handle::before {
                content: '';
                position: absolute;
                top: -8px;
                bottom: -8px;
                left: -8px;
                right: -8px;
            }

            /* Improved readability */
            body {
                font-size: 16px;
                line-height: 1.7;
            }

            /* Better modal behavior */
            .dialog {
                max-height: 90vh;
                overflow-y: auto;
            }

            /* History panel improvements */
            .history-panel {
                box-shadow: -10px 0 40px rgba(0, 0, 0, 0.9);
            }

            /* Presence indicator adjustments */
            .presence-list {
                flex-wrap: wrap;
                gap: 8px;
            }
        }

        /* Loading Spinner */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-pink);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Preview Modal */
        .preview-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            overflow-y: auto;
        }

        .preview-overlay.open {
            display: block;
        }

        .preview-container {
            max-width: 900px;
            margin: 40px auto;
            background:
                linear-gradient(135deg, rgba(20, 10, 10, 0.95), rgba(30, 15, 15, 0.98)),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(139, 0, 0, 0.02) 2px,
                    rgba(139, 0, 0, 0.02) 4px
                );
            border: 3px solid #8b0000;
            padding: 60px;
            box-shadow:
                0 0 0 1px rgba(255, 105, 180, 0.3),
                0 0 30px rgba(139, 0, 0, 0.6),
                inset 0 0 100px rgba(0, 0, 0, 0.8),
                0 20px 60px rgba(0, 0, 0, 0.5);
            min-height: calc(100vh - 80px);
            position: relative;
            border-radius: 5px;
        }

        /* Leather texture for preview */
        .preview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 30% 40%, rgba(80, 40, 40, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 70% 60%, rgba(80, 40, 40, 0.15) 0%, transparent 50%);
            pointer-events: none;
            border-radius: 5px;
        }

        /* Pink bows for preview */
        .preview-bow {
            position: absolute;
            font-size: 60px;
            z-index: 10;
            filter: drop-shadow(3px 3px 10px rgba(255, 105, 180, 0.5));
            opacity: 0.9;
        }

        .preview-bow-top-left {
            top: -20px;
            left: -20px;
            transform: rotate(-15deg);
        }

        .preview-bow-top-right {
            top: -20px;
            right: -20px;
            transform: rotate(15deg);
        }

        .preview-bow-bottom-left {
            bottom: -20px;
            left: -20px;
            transform: rotate(15deg);
        }

        .preview-bow-bottom-right {
            bottom: -20px;
            right: -20px;
            transform: rotate(-15deg);
        }

        .preview-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary-light) 100%);
            padding: 15px 25px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 20px;
            z-index: 3001;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.6);
        }

        .preview-header h3 {
            color: var(--accent-pink);
            font-family: 'Cinzel', serif;
            margin: 0;
            font-size: 1.3em;
        }

        .preview-presence-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .preview-presence-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 14px;
            border-radius: 20px;
            border: 1px solid rgba(255, 105, 180, 0.3);
            font-size: 12px;
        }

        .preview-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .preview-content {
            margin-top: 70px;
            color: #ffb6c1;
            font-family: 'Crimson Text', serif;
            line-height: 1.8;
            position: relative;
            z-index: 1;
        }

        .preview-content h1 {
            font-family: 'Cinzel', serif;
            font-size: 44px;
            font-weight: 700;
            background: linear-gradient(135deg, #8b0000, #ff69b4, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 30px rgba(255, 105, 180, 0.3);
        }

        .preview-content h2 {
            font-family: 'Cinzel', serif;
            font-size: 26px;
            color: #dc143c;
            margin-bottom: 20px;
            margin-top: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .preview-content h2::before {
            content: '🎀';
            font-size: 22px;
            filter: drop-shadow(0 0 5px rgba(255, 105, 180, 0.5));
        }

        .preview-content h2::after {
            content: '🎀';
            font-size: 22px;
            filter: drop-shadow(0 0 5px rgba(255, 105, 180, 0.5));
        }

        .preview-content h3 {
            font-family: 'Crimson Text', serif;
            font-size: 13px;
            color: #d4768f;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
            margin-top: 20px;
            display: block;
        }

        .preview-subtitle {
            text-align: center;
            color: #d4768f;
            font-size: 16px;
            font-style: italic;
            margin-top: 15px;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 2px solid rgba(139, 0, 0, 0.6);
            position: relative;
            font-family: 'Crimson Text', serif;
        }

        .preview-subtitle::after {
            content: '⛓️ 🎀 ⛓️';
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            background: linear-gradient(135deg, rgba(20, 10, 10, 0.95), rgba(30, 15, 15, 0.98));
            padding: 0 20px;
        }

        .preview-inline-name-input {
            border: none;
            border-bottom: 1px solid rgba(139, 0, 0, 0.6);
            background: rgba(255, 255, 255, 0.03);
            font-family: 'Crimson Text', serif;
            font-size: 16px;
            font-style: italic;
            color: #ff6b9d;
            text-align: center;
            padding: 5px 12px;
            min-width: 120px;
            cursor: default;
        }

        .preview-inline-name-input:focus {
            outline: none;
        }

        .preview-divider {
            text-align: center;
            font-size: 24px;
            margin: 35px 0;
            color: #ffb6c1;
            opacity: 0.8;
        }

        .preview-content p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .preview-content .preview-subtitle {
            text-align: center !important;
        }

        .preview-content ul {
            list-style: none;
            padding-left: 0;
        }

        .preview-content li {
            margin-bottom: 12px;
            padding-left: 30px;
            position: relative;
        }

        .preview-content li::before {
            content: "🎀";
            position: absolute;
            left: 0;
            color: var(--accent-pink);
        }

        .preview-empty {
            color: rgba(255, 182, 193, 0.4);
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .preview-date {
            text-align: center;
            color: #d4768f;
            font-style: italic;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid rgba(139, 0, 0, 0.6);
        }

        /* Terms Notice */
        .preview-terms-notice {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(139, 0, 0, 0.3);
            border-left: 4px solid #8b0000;
            padding: 20px;
            margin: 30px 0;
            font-size: 16px;
            color: #d4768f;
            font-style: italic;
            line-height: 1.8;
            border-radius: 3px;
        }

        /* Signature Section */
        .preview-signature-section {
            margin-top: 50px;
            padding-top: 40px;
            border-top: 2px solid rgba(139, 0, 0, 0.6);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 50px;
        }

        .preview-signature-box {
            text-align: center;
            position: relative;
        }

        .preview-signature-box::before {
            content: '🎀';
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            filter: drop-shadow(0 0 8px rgba(255, 105, 180, 0.6));
        }

        .preview-signature-box label {
            display: block;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            color: #dc143c;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .preview-signature-value {
            width: 100%;
            border: none;
            border-bottom: 2px solid rgba(139, 0, 0, 0.6);
            background: transparent;
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive;
            font-size: 26px;
            color: #ff6b9d;
            text-align: center;
            padding: 10px 0;
            min-height: 40px;
        }

        .preview-signature-date {
            font-family: 'Crimson Text', serif;
            font-size: 14px;
            margin-top: 15px;
            color: #d4768f;
            text-align: center;
        }

        @media (max-width: 768px) {
            .preview-signature-section {
                grid-template-columns: 1fr;
                gap: 50px;
            }
        }

        /* Preview Readonly Field Styles */
        .preview-field-group {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(139, 0, 0, 0.2);
        }

        .preview-field-label {
            display: block;
            font-family: 'Crimson Text', serif;
            font-size: 13px;
            color: #d4768f;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 10px;
        }

        .preview-readonly-input,
        .preview-readonly-textarea {
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(139, 0, 0, 0.3);
            border-radius: 3px;
            padding: 10px;
            color: #ffb6c1;
            font-family: 'Crimson Text', serif;
            font-size: 16px;
            line-height: 1.6;
            cursor: default;
            opacity: 0.95;
        }

        .preview-readonly-input:focus,
        .preview-readonly-textarea:focus {
            outline: none;
            border-color: rgba(139, 0, 0, 0.5);
        }

        .preview-readonly-textarea {
            min-height: 80px;
            resize: none;
        }

        .preview-list-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .preview-list-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-list-bow {
            font-size: 16px;
            filter: drop-shadow(0 0 3px rgba(255, 105, 180, 0.5));
            flex-shrink: 0;
        }

        .preview-list-item .preview-readonly-input {
            flex: 1;
        }

        .preview-signature-input {
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive;
            font-size: 22px;
            text-align: center;
            background: rgba(0, 0, 0, 0.15);
            border-bottom: 2px solid rgba(139, 0, 0, 0.6);
            border-radius: 0;
            padding: 15px 10px;
        }

        .preview-date-input {
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.15);
            padding: 8px;
        }

        /* Settings Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 4000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(20, 10, 10, 0.98), rgba(30, 15, 15, 0.98));
            border: 2px solid var(--primary-light);
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .modal-header {
            padding: 25px;
            border-bottom: 2px solid rgba(139, 0, 0, 0.6);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-family: 'Cinzel', serif;
            color: var(--accent-pink);
            margin: 0;
            font-size: 24px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--accent-light-pink);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: var(--accent-pink);
        }

        .modal-body {
            padding: 25px;
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-section label {
            display: block;
            font-family: 'Cinzel', serif;
            font-size: 14px;
            color: #dc143c;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(139, 0, 0, 0.6);
            border-radius: 6px;
            color: var(--accent-light-pink);
            font-family: 'Crimson Text', serif;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-pink);
        }

        .help-text {
            margin-top: 8px;
            font-size: 13px;
            color: rgba(255, 182, 193, 0.6);
            font-style: italic;
        }

        .read-only-value {
            color: var(--accent-light-pink);
            font-size: 16px;
            padding: 10px 0;
        }

        .modal-footer {
            padding: 20px 25px;
            border-top: 2px solid rgba(139, 0, 0, 0.6);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Animations for Presence Notifications */
        @keyframes slideDown {
            from {
                transform: translate(-50%, -20px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        @keyframes fadeInSlideDown {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Print Styles */
        @media print {
            .app-header,
            .editor-actions,
            .section-actions,
            .add-item-btn,
            .remove-btn,
            .history-panel,
            .dialog-overlay,
            .preview-header {
                display: none !important;
            }

            .preview-overlay {
                display: block !important;
                background: white !important;
            }

            .preview-container {
                margin: 0 !important;
                padding: 20px !important;
                box-shadow: none !important;
            }

            .preview-content {
                margin-top: 0 !important;
            }

            body {
                background: white;
                color: black;
            }

            .contract-section {
                page-break-inside: avoid;
                border-color: black;
            }

            .preview-content h2 {
                page-break-after: avoid;
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Screen -->
    <div id="auth-screen">
        <div class="auth-container">
            <h1>⛓️ D/s Dynamic Contract 🎀</h1>
            <p class="subtitle">Real-time collaborative edition</p>

            <div class="error-message" id="auth-error"></div>
            <div class="success-message" id="auth-success"></div>

            <div class="auth-tabs">
                <button class="auth-tab active" data-tab="login">Login</button>
                <button class="auth-tab" data-tab="signup">Sign Up</button>
            </div>

            <!-- Login Form -->
            <form id="login-form" class="auth-form active">
                <div class="form-group">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" required placeholder="your@email.com">
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" required placeholder="••••••••">
                </div>
                <button type="submit" class="auth-button">
                    <span class="btn-text">Login</span>
                    <span class="loading" style="display: none;"></span>
                </button>
            </form>

            <!-- Signup Form -->
            <form id="signup-form" class="auth-form">
                <div class="form-group">
                    <label for="signup-email">Email</label>
                    <input type="email" id="signup-email" required placeholder="your@email.com">
                </div>
                <div class="form-group">
                    <label for="signup-password">Password</label>
                    <input type="password" id="signup-password" required placeholder="••••••••" minlength="6">
                </div>
                <div class="form-group">
                    <label for="signup-display-name">Display Name</label>
                    <input type="text" id="signup-display-name" required placeholder="Your name">
                </div>
                <button type="submit" class="auth-button">
                    <span class="btn-text">Create Account</span>
                    <span class="loading" style="display: none;"></span>
                </button>
            </form>
        </div>
    </div>

    <!-- Main Application Screen -->
    <div id="app-screen">
        <!-- Header -->
        <header class="app-header">
            <h1>⛓️ D/s Dynamic Contract 🎀</h1>

            <!-- Presence Section (Centered) -->
            <div class="header-presence-section" id="header-presence-section" style="display: none;">
                <div class="presence-badge" id="presence-badge">
                    <span class="presence-dot"></span>
                    <span id="presence-count" class="presence-count">1 online</span>
                </div>
                <div class="multi-editor-badge" id="multi-editor-badge" style="display: none;">
                    <span>⚠️</span>
                    <span id="multi-editor-text">Multiple editors</span>
                </div>

                <!-- Presence Dropdown -->
                <div class="presence-dropdown" id="presence-dropdown">
                    <div class="presence-dropdown-header">
                        <span>👥</span>
                        <span id="presence-dropdown-title">People Online</span>
                    </div>
                    <div id="presence-user-list">
                        <!-- Users will be listed here -->
                    </div>
                </div>
            </div>

            <!-- Header Controls (Right) -->
            <div class="header-controls">
                <button class="btn btn-secondary" id="user-menu-btn">
                    <span id="user-email"></span>
                </button>
                <button class="btn btn-secondary btn-icon" id="settings-btn" title="Settings">⚙️</button>
                <button class="btn" id="logout-btn">Logout</button>
            </div>
        </header>

        <!-- Contract List View -->
        <div class="contract-list-screen" id="contract-list">
            <div class="contract-list-header">
                <h2>Your Contracts</h2>
                <button class="btn" id="create-contract-btn">+ Create New Contract</button>
            </div>
            <div class="contracts-grid" id="contracts-grid">
                <!-- Contracts will be loaded here -->
            </div>
        </div>

        <!-- Contract Editor View -->
        <div class="contract-editor" id="contract-editor">
            <div class="editor-header">
                <div class="editor-title">
                    <input type="text" id="contract-title" placeholder="Contract Title">
                </div>
                <div class="editor-actions">
                    <div class="sync-status">
                        <span class="sync-dot" id="sync-dot"></span>
                        <span id="sync-text">Synced</span>
                    </div>
                    <div class="undo-redo-group" style="position: relative;">
                        <button class="undo-redo-btn" id="undo-btn" title="Undo" disabled>
                            ↶
                            <span class="shortcut-hint">Ctrl+Z</span>
                        </button>
                        <button class="undo-redo-btn" id="redo-btn" title="Redo" disabled>
                            ↷
                            <span class="shortcut-hint">Ctrl+Y</span>
                        </button>
                        <button class="undo-redo-btn" id="undo-history-toggle" title="Undo History" disabled>
                            ⋮
                        </button>
                        <div class="undo-history-dropdown" id="undo-history-dropdown">
                            <div class="undo-history-header">Undo History</div>
                            <div id="undo-history-list">
                                <!-- History items will be populated here -->
                            </div>
                        </div>
                    </div>
                    <button class="btn" id="preview-btn">👁️ Preview</button>
                    <button class="btn btn-secondary" id="history-btn">📜 History</button>
                    <button class="btn btn-secondary" id="share-btn">🔗 Share</button>
                    <button class="btn" id="save-snapshot-btn">📸 Snapshot</button>
                    <button class="btn btn-secondary" id="back-to-list-btn">← Back</button>
                </div>
            </div>

            <!-- Contract Content Area -->
            <div class="contract-content-area">
                <!-- Pink bows in corners -->
                <div class="content-bow bow-top-left">🎀</div>
                <div class="content-bow bow-top-right">🎀</div>
                <div class="content-bow bow-bottom-left">🎀</div>
                <div class="content-bow bow-bottom-right">🎀</div>

                <!-- Contract Header -->
                <div class="contract-header">
                    <h1 class="contract-display-title" id="contract-display-title">D/s Dynamic Contract</h1>
                    <div class="contract-subtitle">
                        Between Dom
                        <input type="text" id="dominant-name" placeholder="Name" class="inline-name-input">
                        and his sub
                        <input type="text" id="submissive-name" placeholder="Name" class="inline-name-input">
                    </div>
                </div>

                <!-- Contract Sections -->
                <div id="contract-sections">
                    <!-- Sections will be dynamically loaded here -->
                </div>
            </div>

            <button class="btn" id="add-section-btn" style="width: 100%; margin-top: 20px;">+ Add Section</button>

            <!-- Signature Section -->
            <div class="contract-section" style="margin-top: 50px; padding-top: 40px; border-top: 2px solid var(--border-color);">
                <h2 style="text-align: center; color: var(--accent-pink); margin-bottom: 30px;">Signatures</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 40px;">
                    <div>
                        <label style="display: block; color: var(--accent-pink); margin-bottom: 10px; font-weight: 600;">Owner's Signature</label>
                        <input type="text" id="owner-signature" placeholder="Sign here" style="width: 100%; font-family: 'Brush Script MT', 'Lucida Handwriting', cursive; font-size: 24px; padding: 10px; border: none; border-bottom: 2px solid var(--border-color); background: transparent; color: var(--text-color);">
                        <input type="date" id="owner-signature-date" style="width: 100%; margin-top: 10px; padding: 8px; background: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color);">
                    </div>
                    <div>
                        <label style="display: block; color: var(--accent-pink); margin-bottom: 10px; font-weight: 600;">Submissive's Acceptance</label>
                        <input type="text" id="submissive-signature" placeholder="Sign here" style="width: 100%; font-family: 'Brush Script MT', 'Lucida Handwriting', cursive; font-size: 24px; padding: 10px; border: none; border-bottom: 2px solid var(--border-color); background: transparent; color: var(--text-color);">
                        <input type="date" id="submissive-signature-date" style="width: 100%; margin-top: 10px; padding: 8px; background: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color);">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- History Panel -->
    <div class="history-panel" id="history-panel">
        <div class="history-header">
            <h3>Change History</h3>
            <button class="btn btn-secondary" id="close-history-btn">✕</button>
        </div>

        <!-- History Filters -->
        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-bottom: 1px solid var(--border-color);">
            <div style="margin-bottom: 10px;">
                <input
                    type="text"
                    id="history-search"
                    placeholder="🔍 Search changes..."
                    style="width: 100%; padding: 8px 12px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-color);"
                >
            </div>
            <div style="display: flex; gap: 10px;">
                <select
                    id="history-user-filter"
                    style="flex: 1; padding: 8px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-color);"
                >
                    <option value="all">👥 All Users</option>
                </select>
                <select
                    id="history-date-filter"
                    style="flex: 1; padding: 8px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-color);"
                >
                    <option value="all">📅 All Time</option>
                    <option value="today">Today</option>
                    <option value="yesterday">Yesterday</option>
                    <option value="week">This Week</option>
                    <option value="month">This Month</option>
                    <option value="older">Older</option>
                </select>
            </div>
        </div>

        <div class="history-timeline" id="history-timeline">
            <!-- History items will be loaded here -->
        </div>

        <div id="history-load-more" style="padding: 15px; text-align: center; display: none;">
            <button class="btn btn-secondary" onclick="loadMoreHistory()">Load More</button>
        </div>
    </div>

    <!-- Share Dialog -->
    <div class="dialog-overlay" id="share-dialog">
        <div class="dialog">
            <h3>Share Contract</h3>

            <!-- Public Sharing Section -->
            <div class="form-group" style="background: rgba(139, 0, 0, 0.1); padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                <h4 style="color: var(--accent-pink); margin: 0 0 10px;">🌐 Public Sharing (No Account Needed)</h4>
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin: 0;">
                        <input type="checkbox" id="public-share-toggle" style="cursor: pointer;">
                        <span>Enable public link</span>
                    </label>
                </div>
                <div id="public-link-container" style="display: none;">
                    <div class="form-group" style="margin: 10px 0;">
                        <label for="public-share-role">Public Link Permission</label>
                        <select id="public-share-role">
                            <option value="viewer">Viewer (read-only)</option>
                            <option value="editor">Editor (can edit)</option>
                        </select>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 0.9em; margin: 10px 0;">Anyone with this link can access the contract:</p>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="public-link" readonly style="flex: 1; background: rgba(0,0,0,0.3); cursor: text;">
                        <button class="btn btn-secondary" id="copy-link-btn">📋 Copy</button>
                    </div>
                </div>
            </div>

            <!-- Email Sharing Section -->
            <h4 style="color: var(--accent-pink); margin: 0 0 10px;">📧 Share with Registered Users</h4>
            <div class="form-group">
                <label for="share-email">Partner's Email</label>
                <input type="email" id="share-email" placeholder="partner@email.com">
            </div>
            <div class="form-group">
                <label for="share-role">Role</label>
                <select id="share-role">
                    <option value="editor">Editor (can edit)</option>
                    <option value="viewer">Viewer (read-only)</option>
                </select>
            </div>
            <div id="current-shares">
                <h4 style="color: var(--accent-pink); margin: 20px 0 10px;">Current Shares:</h4>
                <div id="shares-list"></div>
            </div>
            <div class="dialog-actions">
                <button class="btn btn-secondary" id="cancel-share-btn">Cancel</button>
                <button class="btn" id="confirm-share-btn">Share</button>
            </div>
        </div>
    </div>

    <!-- Preview Overlay -->
    <div class="preview-overlay" id="preview-overlay">
        <div class="preview-header">
            <h3>📄 Contract Preview</h3>

            <!-- Presence Section (Centered) -->
            <div class="preview-presence-section" id="preview-presence-section" style="display: none;">
                <div class="preview-presence-badge">
                    <span class="presence-dot"></span>
                    <span id="preview-presence-count">1 online</span>
                </div>
            </div>

            <!-- Preview Actions (Right) -->
            <div class="preview-actions">
                <button class="btn btn-secondary" onclick="window.print()">🖨️ Print</button>
                <button class="btn" id="close-preview-btn">✕ Close</button>
            </div>
        </div>
        <div class="preview-container">
            <div class="preview-content" id="preview-content">
                <!-- Preview content will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>⚙️ Account Settings</h2>
                <button class="modal-close" id="close-settings-btn">✕</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <label for="display-name-input">Display Name</label>
                    <input type="text" id="display-name-input" class="form-input" placeholder="Enter your display name" maxlength="50">
                    <p class="help-text">This name will be shown to others when you're online</p>
                </div>
                <div class="settings-section">
                    <label>Email</label>
                    <p id="settings-email" class="read-only-value"></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-settings-btn">Cancel</button>
                <button class="btn" id="save-settings-btn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // ============================================
        // SUPABASE CONFIGURATION
        // ============================================
        const SUPABASE_URL = 'https://sryxyqioytqxcmgtykao.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyeXh5cWlveXRxeGNtZ3R5a2FvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE4MzY4NjMsImV4cCI6MjA3NzQxMjg2M30.QJxb6sUEngf-KEheV9C1Wj14_dDADzuW7PrQtAUcqPo';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ============================================
        // APPLICATION STATE
        // ============================================
        let currentUser = null;
        let currentUserProfile = null;
        let currentContract = null;
        let realtimeChannel = null;
        let presenceChannel = null;
        let historyChannel = null;
        let saveTimeout = null;
        let isSyncing = false;
        let isApplyingRemoteUpdate = false; // Flag to prevent save during sync updates
        let lastSaveTimestamp = 0;
        let pollingInterval = null;
        let usePolling = false;

        // ============================================
        // UNDO/REDO SYSTEM
        // ============================================
        let undoStack = []; // Array of previous states
        let redoStack = []; // Array of undone states
        let currentStateIndex = -1; // Current position in history
        let isUndoRedoAction = false; // Flag to prevent undo/redo from being added to stack
        let lastCapturedState = null; // Last state we captured (for deduplication)
        const MAX_UNDO_STACK_SIZE = 50; // Maximum number of undo states to keep

        // Capture current state for undo/redo
        function captureStateForUndo(description = 'Edit') {
            if (!currentContract || isUndoRedoAction || isApplyingRemoteUpdate) {
                return;
            }

            // Collect current form data before capturing
            collectFormData();

            // Create a deep copy of the contract state
            const state = {
                contractData: JSON.parse(JSON.stringify(currentContract)),
                description: description,
                timestamp: Date.now()
            };

            // Check if this state is different from the last captured state
            // (to avoid capturing duplicate states from multiple events)
            if (lastCapturedState &&
                JSON.stringify(state.contractData.data) === JSON.stringify(lastCapturedState.data)) {
                return;
            }

            lastCapturedState = state.contractData.data;

            // Clear redo stack when new action is performed
            redoStack = [];

            // Add to undo stack
            undoStack.push(state);

            // Limit stack size
            if (undoStack.length > MAX_UNDO_STACK_SIZE) {
                undoStack.shift();
            }

            currentStateIndex = undoStack.length - 1;

            console.log(`📝 Captured state: ${description} (stack size: ${undoStack.length})`);
            updateUndoRedoUI();
        }

        // Perform undo
        function performUndo() {
            if (undoStack.length === 0) {
                console.log('⏮️ Nothing to undo');
                return;
            }

            isUndoRedoAction = true;

            // Capture current state before undo (for redo)
            collectFormData();
            const currentState = {
                contractData: JSON.parse(JSON.stringify(currentContract)),
                description: 'Current state',
                timestamp: Date.now()
            };

            // Add current state to redo stack
            redoStack.push(currentState);

            // Get previous state
            const previousState = undoStack.pop();
            currentStateIndex = undoStack.length - 1;

            // Restore the previous state
            restoreState(previousState.contractData);

            console.log(`⏮️ Undo: ${previousState.description}`);
            updateUndoRedoUI();
            showUndoNotification(`Undone: ${previousState.description}`);

            // Save to database
            setTimeout(() => {
                saveContract();
                isUndoRedoAction = false;
            }, 100);
        }

        // Perform redo
        function performRedo() {
            if (redoStack.length === 0) {
                console.log('⏭️ Nothing to redo');
                return;
            }

            isUndoRedoAction = true;

            // Capture current state before redo (for undo)
            collectFormData();
            const currentState = {
                contractData: JSON.parse(JSON.stringify(currentContract)),
                description: 'Previous state',
                timestamp: Date.now()
            };

            // Add current state back to undo stack
            undoStack.push(currentState);

            // Get redo state
            const redoState = redoStack.pop();
            currentStateIndex = undoStack.length - 1;

            // Restore the redo state
            restoreState(redoState.contractData);

            console.log(`⏭️ Redo: ${redoState.description}`);
            updateUndoRedoUI();
            showUndoNotification(`Redone: ${redoState.description}`);

            // Save to database
            setTimeout(() => {
                saveContract();
                isUndoRedoAction = false;
            }, 100);
        }

        // Restore a saved state
        function restoreState(contractData) {
            // Update current contract
            currentContract = JSON.parse(JSON.stringify(contractData));

            // Update the UI
            document.getElementById('contract-title').value = currentContract.title || '';
            document.getElementById('contract-display-title').textContent = currentContract.title || 'D/s Dynamic Contract';
            document.getElementById('dominant-name').value = currentContract.dominant_name || '';
            document.getElementById('submissive-name').value = currentContract.submissive_name || '';
            document.getElementById('owner-signature').value = currentContract.owner_signature || '';
            document.getElementById('owner-signature-date').value = currentContract.owner_signature_date || '';
            document.getElementById('submissive-signature').value = currentContract.submissive_signature || '';
            document.getElementById('submissive-signature-date').value = currentContract.submissive_signature_date || '';

            // Re-render the contract editor
            renderContractEditor();
        }

        // Update undo/redo button states
        function updateUndoRedoUI() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const historyToggle = document.getElementById('undo-history-toggle');

            if (undoBtn) {
                undoBtn.disabled = undoStack.length === 0;
            }
            if (redoBtn) {
                redoBtn.disabled = redoStack.length === 0;
            }
            if (historyToggle) {
                historyToggle.disabled = undoStack.length === 0;
            }

            // Update history dropdown
            updateUndoHistoryDropdown();
        }

        // Update the undo history dropdown
        function updateUndoHistoryDropdown() {
            const historyList = document.getElementById('undo-history-list');
            if (!historyList) return;

            historyList.innerHTML = '';

            if (undoStack.length === 0) {
                historyList.innerHTML = '<div style="padding: 10px; color: var(--accent-light-pink); text-align: center;">No history available</div>';
                return;
            }

            // Show last 20 items
            const recentStates = undoStack.slice(-20).reverse();

            recentStates.forEach((state, index) => {
                const actualIndex = undoStack.length - 1 - index;
                const isCurrent = actualIndex === currentStateIndex;

                const item = document.createElement('div');
                item.className = `undo-history-item${isCurrent ? ' current' : ''}`;
                item.innerHTML = `
                    <div class="action-desc">${state.description}</div>
                    <div class="action-time">${formatTimestamp(state.timestamp)}</div>
                `;

                item.addEventListener('click', () => {
                    jumpToHistoryState(actualIndex);
                    toggleUndoHistoryDropdown(false);
                });

                historyList.appendChild(item);
            });
        }

        // Jump to a specific state in history
        function jumpToHistoryState(targetIndex) {
            if (targetIndex < 0 || targetIndex >= undoStack.length) return;

            isUndoRedoAction = true;

            // Get the target state
            const targetState = undoStack[targetIndex];

            // Move states between undo and redo stacks as needed
            if (targetIndex < currentStateIndex) {
                // Moving backward - perform multiple undos
                while (currentStateIndex > targetIndex && undoStack.length > 0) {
                    performUndo();
                }
            } else if (targetIndex > currentStateIndex) {
                // Moving forward - perform multiple redos
                while (currentStateIndex < targetIndex && redoStack.length > 0) {
                    performRedo();
                }
            }

            isUndoRedoAction = false;
        }

        // Format timestamp for display
        function formatTimestamp(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;

            if (diff < 1000) return 'just now';
            if (diff < 60000) return Math.floor(diff / 1000) + 's ago';
            if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
            if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';

            const date = new Date(timestamp);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Show undo notification
        function showUndoNotification(message) {
            // Reuse existing sync notification system
            const existingNotification = document.querySelector('.undo-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            const notification = document.createElement('div');
            notification.className = 'undo-notification';
            notification.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(220, 20, 60, 0.95));
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                border: 2px solid var(--accent-pink);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                z-index: 10000;
                font-size: 14px;
                animation: slideUp 0.3s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideDown 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }

        // Toggle undo history dropdown
        function toggleUndoHistoryDropdown(show) {
            const dropdown = document.getElementById('undo-history-dropdown');
            if (!dropdown) return;

            if (show === undefined) {
                dropdown.classList.toggle('show');
            } else if (show) {
                dropdown.classList.add('show');
                updateUndoHistoryDropdown();
            } else {
                dropdown.classList.remove('show');
            }
        }

        // Setup keyboard shortcuts for undo/redo
        function setupUndoRedoKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Z or Cmd+Z for undo
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    performUndo();
                }
                // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    performRedo();
                }
            });
        }

        // Initialize undo/redo system
        function initUndoRedoSystem() {
            // Setup button click handlers
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const historyToggle = document.getElementById('undo-history-toggle');

            if (undoBtn) {
                undoBtn.addEventListener('click', performUndo);
            }
            if (redoBtn) {
                redoBtn.addEventListener('click', performRedo);
            }
            if (historyToggle) {
                historyToggle.addEventListener('click', () => toggleUndoHistoryDropdown());
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                const dropdown = document.getElementById('undo-history-dropdown');
                const toggle = document.getElementById('undo-history-toggle');
                if (dropdown && !dropdown.contains(e.target) && e.target !== toggle) {
                    toggleUndoHistoryDropdown(false);
                }
            });

            // Setup keyboard shortcuts
            setupUndoRedoKeyboardShortcuts();

            console.log('✅ Undo/Redo system initialized');
        }

        // ============================================
        // AUTHENTICATION
        // ============================================

        // Check for existing session on load
        async function checkAuth() {
            // Check if accessing via public share link
            const urlParams = new URLSearchParams(window.location.search);
            const publicToken = urlParams.get('share');

            if (publicToken) {
                // Public access mode - no login required
                await loadPublicContract(publicToken);
                return;
            }

            // Normal auth flow
            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session) {
                currentUser = session.user;
                showApp();
            } else {
                // No session - ensure auth screen is visible
                document.getElementById('auth-screen').style.display = 'flex';
                document.getElementById('app-screen').style.display = 'none';
            }
        }

        // Load contract via public share token
        async function loadPublicContract(token) {
            try {
                const { data, error } = await supabaseClient
                    .from('contracts')
                    .select('*')
                    .eq('public_share_token', token)
                    .eq('is_public', true)
                    .single();

                if (error || !data) {
                    alert('Invalid or expired share link');
                    window.location.href = window.location.pathname; // Remove token from URL
                    return;
                }

                // Set as current contract
                currentContract = data;
                const isEditor = data.public_share_role === 'editor';

                // Reset undo/redo stacks for new contract
                undoStack = [];
                redoStack = [];
                currentStateIndex = -1;
                lastCapturedState = null;
                updateUndoRedoUI();

                // Hide auth screen and show main app
                document.getElementById('auth-screen').style.display = 'none';
                document.getElementById('app-screen').style.display = 'block';

                if (isEditor) {
                    // Create a guest user for public editing
                    currentUser = {
                        id: 'public-editor',
                        email: 'public-editor@guest',
                        isPublicEditor: true
                    };

                    // Show contract editor (hide list view)
                    const contractList = document.getElementById('contract-list');
                    const contractEditor = document.getElementById('contract-editor');

                    if (contractList) contractList.style.display = 'none';
                    if (contractEditor) contractEditor.style.display = 'block';

                    // Set contract title and names
                    document.getElementById('contract-title').value = currentContract.title;
                    document.getElementById('contract-display-title').textContent = currentContract.title || 'D/s Dynamic Contract';
                    document.getElementById('dominant-name').value = currentContract.dominant_name || 'Matthew';
                    document.getElementById('submissive-name').value = currentContract.submissive_name || 'Shailah';

                    // Load signatures
                    document.getElementById('owner-signature').value = currentContract.owner_signature || '';
                    document.getElementById('owner-signature-date').value = currentContract.owner_signature_date || '';
                    document.getElementById('submissive-signature').value = currentContract.submissive_signature || '';
                    document.getElementById('submissive-signature-date').value = currentContract.submissive_signature_date || '';

                    // Hide buttons that shouldn't be available to public editors
                    const backBtn = document.getElementById('back-to-list-btn');
                    const shareBtn = document.getElementById('share-btn');
                    const historyBtn = document.getElementById('history-btn');
                    const snapshotBtn = document.getElementById('save-snapshot-btn');

                    if (backBtn) backBtn.style.display = 'none';
                    if (shareBtn) shareBtn.style.display = 'none';
                    if (historyBtn) historyBtn.style.display = 'none';
                    if (snapshotBtn) snapshotBtn.style.display = 'none';

                    renderContractEditor();
                    setupRealtimeSync();
                    setupPresence(); // Enable presence for public editors

                    // Add indicator that this is public editing
                    const editorActions = document.querySelector('.editor-actions');
                    if (editorActions) {
                        const indicator = document.createElement('div');
                        indicator.style.cssText = 'color: var(--accent-pink); font-size: 0.9em; font-weight: 600;';
                        indicator.textContent = '🌐 Public Editor Mode';
                        editorActions.insertBefore(indicator, editorActions.firstChild);
                    }
                } else {
                    // Viewers also get presence (but read-only)
                    currentUser = {
                        id: `viewer-${Date.now()}`,
                        email: 'public-viewer@guest',
                        isPublicViewer: true
                    };

                    // Show preview for viewers
                    renderPreview();
                    document.getElementById('preview-overlay').classList.add('open');
                    setupPresence(); // Enable presence for viewers too

                    // Add message to preview
                    const previewHeader = document.querySelector('.preview-header h3');
                    if (previewHeader) {
                        previewHeader.innerHTML = '📄 ' + (data.title || 'Contract Preview') + ' <span style="color: var(--accent-pink); font-size: 0.7em; margin-left: 10px;">(Shared View)</span>';
                    }
                }
            } catch (err) {
                console.error('Error loading public contract:', err);
                alert('Error loading shared contract');
            }
        }

        // Auth tab switching
        document.querySelectorAll('.auth-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tabName}-form`).classList.add('active');
                hideAuthMessages();
            });
        });

        // Login
        document.getElementById('login-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;

            showAuthLoading(true);
            hideAuthMessages();

            const { data, error } = await supabaseClient.auth.signInWithPassword({
                email,
                password
            });

            if (error) {
                showAuthError(error.message);
            } else {
                currentUser = data.user;
                showApp();
            }

            showAuthLoading(false);
        });

        // Signup
        document.getElementById('signup-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;
            const displayName = document.getElementById('signup-display-name').value;

            showAuthLoading(true);
            hideAuthMessages();

            const { data, error } = await supabaseClient.auth.signUp({
                email,
                password,
                options: {
                    data: {
                        display_name: displayName
                    }
                }
            });

            if (error) {
                showAuthError(error.message);
            } else {
                showAuthSuccess('Account created! Please check your email to verify.');
            }

            showAuthLoading(false);
        });

        // Logout
        document.getElementById('logout-btn').addEventListener('click', async () => {
            try {
                // Clean up realtime connections
                if (realtimeChannel) {
                    await supabaseClient.removeChannel(realtimeChannel);
                    realtimeChannel = null;
                }
                if (presenceChannel) {
                    await supabaseClient.removeChannel(presenceChannel);
                    presenceChannel = null;
                }

                // Sign out from Supabase - wait for it to complete
                const { error } = await supabaseClient.auth.signOut();
                if (error) {
                    console.error('Signout error:', error);
                }

                // Clear current user state
                currentUser = null;
                currentContract = null;

                // Clear contracts grid
                const grid = document.getElementById('contracts-grid');
                if (grid) grid.innerHTML = '';

                // Hide app screen and show auth screen
                document.getElementById('app-screen').style.display = 'none';
                document.getElementById('auth-screen').style.display = 'flex';

                // Reset auth form
                document.querySelectorAll('.auth-form input').forEach(input => input.value = '');

                // Don't reload - just stay on auth screen
            } catch (error) {
                console.error('Error during logout:', error);
                // Even on error, show auth screen
                document.getElementById('app-screen').style.display = 'none';
                document.getElementById('auth-screen').style.display = 'flex';
            }
        });

        // Settings Modal
        document.getElementById('settings-btn').addEventListener('click', () => {
            // Populate form with current values
            document.getElementById('display-name-input').value = currentUserProfile?.display_name || '';
            document.getElementById('settings-email').textContent = currentUser.email;

            // Show modal
            document.getElementById('settings-modal').classList.add('open');
        });

        document.getElementById('close-settings-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.remove('open');
        });

        document.getElementById('cancel-settings-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.remove('open');
        });

        document.getElementById('save-settings-btn').addEventListener('click', async () => {
            const displayName = document.getElementById('display-name-input').value.trim();

            const saveBtn = document.getElementById('save-settings-btn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;

            const success = await updateUserProfile(displayName || null);

            if (success) {
                document.getElementById('settings-modal').classList.remove('open');
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            } else {
                alert('Failed to save settings. Please try again.');
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            }
        });

        // ============================================
        // PRESENCE DROPDOWN TOGGLE
        // ============================================

        // Toggle presence dropdown
        const presenceBadge = document.getElementById('presence-badge');
        const presenceDropdown = document.getElementById('presence-dropdown');

        if (presenceBadge && presenceDropdown) {
            presenceBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                presenceDropdown.classList.toggle('show');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!presenceDropdown.contains(e.target) && !presenceBadge.contains(e.target)) {
                    presenceDropdown.classList.remove('show');
                }
            });

            // Prevent dropdown from closing when clicking inside it
            presenceDropdown.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }

        // Helper functions for auth UI
        function showAuthLoading(show) {
            const btns = document.querySelectorAll('.auth-button');
            btns.forEach(btn => {
                btn.disabled = show;
                btn.querySelector('.btn-text').style.display = show ? 'none' : 'inline';
                btn.querySelector('.loading').style.display = show ? 'inline-block' : 'none';
            });
        }

        function showAuthError(message) {
            const el = document.getElementById('auth-error');
            el.textContent = message;
            el.style.display = 'block';
        }

        function showAuthSuccess(message) {
            const el = document.getElementById('auth-success');
            el.textContent = message;
            el.style.display = 'block';
        }

        function hideAuthMessages() {
            document.getElementById('auth-error').style.display = 'none';
            document.getElementById('auth-success').style.display = 'none';
        }

        // ============================================
        // USER PROFILE MANAGEMENT
        // ============================================

        async function loadUserProfile() {
            if (!currentUser) return;

            const { data, error } = await supabaseClient
                .from('user_profiles')
                .select('*')
                .eq('id', currentUser.id)
                .single();

            // Handle expected errors (profile doesn't exist yet)
            // PGRST116 = no rows found, 406 = not acceptable (sometimes returned for missing rows)
            if (error && error.code !== 'PGRST116' && error.status !== 406) {
                console.error('Error loading user profile:', error);
                return;
            }

            if (data) {
                currentUserProfile = data;
            } else {
                // Create profile if it doesn't exist
                const { data: newProfile, error: createError } = await supabaseClient
                    .from('user_profiles')
                    .insert({ id: currentUser.id, display_name: null })
                    .select()
                    .single();

                if (createError) {
                    console.error('Error creating user profile:', createError);
                } else {
                    currentUserProfile = newProfile;
                }
            }
        }

        async function updateUserProfile(displayName) {
            if (!currentUser) return false;

            const { data, error } = await supabaseClient
                .from('user_profiles')
                .update({ display_name: displayName })
                .eq('id', currentUser.id)
                .select()
                .single();

            if (error) {
                console.error('Error updating user profile:', error);
                return false;
            }

            currentUserProfile = data;

            // Update display in header
            const displayText = currentUserProfile?.display_name || currentUser.email;
            document.getElementById('user-email').textContent = displayText;

            return true;
        }

        // ============================================
        // APP NAVIGATION
        // ============================================

        async function showApp() {
            document.getElementById('auth-screen').style.display = 'none';
            document.getElementById('app-screen').style.display = 'block';

            // Load user profile
            await loadUserProfile();

            // Display user email or display name
            const displayText = currentUserProfile?.display_name || currentUser.email;
            document.getElementById('user-email').textContent = displayText;

            loadContracts();
            // Don't setup presence here - wait until a contract is opened
        }

        function showContractList() {
            document.getElementById('contract-list').style.display = 'block';
            document.getElementById('contract-editor').style.display = 'none';

            // Hide presence section when not viewing a contract
            const presenceSection = document.getElementById('header-presence-section');
            if (presenceSection) {
                presenceSection.style.display = 'none';
            }

            // Clean up presence channel
            if (presenceChannel) {
                supabaseClient.removeChannel(presenceChannel);
                presenceChannel = null;
            }

            // Clean up history channel
            if (historyChannel) {
                supabaseClient.removeChannel(historyChannel);
                historyChannel = null;
            }

            // Clean up any old presence UI elements that might exist
            const oldWarning = document.getElementById('multi-editor-warning');
            const oldList = document.getElementById('presence-detail-list');
            if (oldWarning) oldWarning.remove();
            if (oldList) oldList.remove();

            // Clean up sync connections
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
                realtimeChannel = null;
            }
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }

            loadContracts();
        }

        function showContractEditor() {
            document.getElementById('contract-list').style.display = 'none';
            document.getElementById('contract-editor').style.display = 'block';

            // Show presence section in header
            const presenceSection = document.getElementById('header-presence-section');
            if (presenceSection) {
                presenceSection.style.display = 'flex';
            }
        }

        document.getElementById('back-to-list-btn').addEventListener('click', showContractList);

        // ============================================
        // CONTRACT LIST
        // ============================================

        async function loadContracts() {
            // Try to load contracts with shares, but fall back if shares table doesn't exist
            let { data, error } = await supabaseClient
                .from('contracts')
                .select(`
                    *,
                    contract_shares(
                        shared_with_email,
                        role
                    )
                `)
                .order('updated_at', { ascending: false });

            // If query failed (possibly because contract_shares doesn't exist yet), try without it
            if (error) {
                console.warn('Failed to load contracts with shares, trying without:', error);
                const result = await supabaseClient
                    .from('contracts')
                    .select('*')
                    .order('updated_at', { ascending: false });

                data = result.data;
                error = result.error;
            }

            if (error) {
                console.error('Error loading contracts:', error);
                alert('Failed to load contracts. Make sure you ran the database schema script.');
                return;
            }

            renderContractList(data || []);
        }

        function renderContractList(contracts) {
            const grid = document.getElementById('contracts-grid');

            if (contracts.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; padding: 60px 20px;">
                        <h3 style="color: var(--accent-pink); margin-bottom: 20px; font-family: 'Cinzel', serif;">
                            No contracts yet
                        </h3>
                        <p style="color: var(--accent-light-pink); margin-bottom: 30px;">
                            Create your first dynamic contract to get started
                        </p>
                        <button class="btn" onclick="createNewContract()">+ Create Contract</button>
                    </div>
                `;
                return;
            }

            grid.innerHTML = contracts.map(contract => {
                const isShared = contract.contract_shares && contract.contract_shares.length > 0;
                const updatedDate = new Date(contract.updated_at).toLocaleDateString();

                return `
                    <div class="contract-card" onclick="openContract('${contract.id}')">
                        ${isShared ? '<span class="shared-badge">Shared</span>' : ''}
                        <h3>${contract.title || 'Untitled Contract'}</h3>
                        <div class="meta">
                            Last updated: ${updatedDate}
                            ${isShared ? `<br>Shared with ${contract.contract_shares.length} partner(s)` : ''}
                        </div>
                        <div class="actions">
                            <button class="btn" onclick="event.stopPropagation(); openContract('${contract.id}')">Open</button>
                            <button class="btn btn-secondary" onclick="event.stopPropagation(); deleteContract('${contract.id}')">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        window.createNewContract = async function() {
            const { data, error } = await supabaseClient
                .from('contracts')
                .insert({
                    user_id: currentUser.id,
                    title: 'New Contract',
                    data: { sections: [] }
                })
                .select()
                .single();

            if (error) {
                console.error('Error creating contract:', error);
                alert('Failed to create contract');
                return;
            }

            openContract(data.id);
        };

        document.getElementById('create-contract-btn').addEventListener('click', createNewContract);

        window.openContract = async function(contractId) {
            const { data, error } = await supabaseClient
                .from('contracts')
                .select('*')
                .eq('id', contractId)
                .single();

            if (error) {
                console.error('Error loading contract:', error);
                alert('Failed to load contract');
                return;
            }

            currentContract = data;

            // Reset undo/redo stacks for new contract
            undoStack = [];
            redoStack = [];
            currentStateIndex = -1;
            lastCapturedState = null;
            updateUndoRedoUI();

            // Load signatures into form
            document.getElementById('owner-signature').value = currentContract.owner_signature || '';
            document.getElementById('owner-signature-date').value = currentContract.owner_signature_date || '';
            document.getElementById('submissive-signature').value = currentContract.submissive_signature || '';
            document.getElementById('submissive-signature-date').value = currentContract.submissive_signature_date || '';

            renderContractEditor();
            setupRealtimeSync();
            setupPresence(); // Setup presence when opening contract
            showContractEditor();

            // Capture initial state after contract is loaded
            setTimeout(() => {
                captureStateForUndo('Initial state');
            }, 500);
        };

        window.deleteContract = async function(contractId) {
            if (!confirm('Are you sure you want to delete this contract?')) {
                return;
            }

            const { error } = await supabaseClient
                .from('contracts')
                .delete()
                .eq('id', contractId);

            if (error) {
                console.error('Error deleting contract:', error);
                alert('Failed to delete contract');
                return;
            }

            loadContracts();
        };

        // ============================================
        // CONTRACT EDITOR
        // ============================================

        function renderContractEditor() {
            document.getElementById('contract-title').value = currentContract.title || '';
            document.getElementById('contract-display-title').textContent = currentContract.title || 'D/s Dynamic Contract';
            document.getElementById('dominant-name').value = currentContract.dominant_name || 'Matthew';
            document.getElementById('submissive-name').value = currentContract.submissive_name || 'Shailah';

            const sectionsContainer = document.getElementById('contract-sections');
            const sections = currentContract.data?.sections || [];

            if (sections.length === 0) {
                // Create default sections matching original template
                const defaultSections = [
                    {
                        type: 'parties',
                        title: 'Parties',
                        fields: [
                            { label: 'Dominant (Owner & Caregiver)', type: 'textarea', value: 'Matthew - Sir, Owner, Daddy' },
                            { label: 'Submissive (Little & Property)', type: 'textarea', value: 'Shailah - little girl, baby girl, princess, pet, toy, belonging' }
                        ]
                    },
                    {
                        type: 'commands',
                        title: 'Commands & Absolute Rules',
                        fields: [
                            { label: 'Command 1', type: 'textarea', value: 'The submissive must obey all commands immediately and without hesitation' },
                            { label: 'Command 2', type: 'textarea', value: 'The submissive belongs completely to the Dominant and exists for His pleasure' },
                            { label: 'Command 3', type: 'textarea', value: 'The submissive must always address the Dominant with respect and proper titles' }
                        ]
                    },
                    {
                        type: 'duties',
                        title: 'Required Duties & Service',
                        fields: [
                            { label: 'Daily Requirements', type: 'list', items: ['Morning greeting and check-in', 'Evening report of daily activities', 'Maintain personal presentation'] },
                            { label: 'Ongoing Expectations', type: 'list', items: ['Respectful communication at all times', 'Prompt responses to messages'] },
                            { label: 'Service Expectations', type: 'textarea', value: 'The submissive is expected to serve with devotion and eagerness, anticipating needs and seeking to please' }
                        ]
                    },
                    {
                        type: 'boundaries',
                        title: 'Boundaries',
                        fields: [
                            { label: 'Hard Limits (Absolute No)', type: 'list', items: ['Anything illegal', 'Permanent marks or modifications without consent', 'Involvement of others without prior discussion'] },
                            { label: 'Soft Limits (Requires Discussion)', type: 'list', items: ['Public display beyond agreed comfort levels', 'Extended time constraints'] },
                            { label: 'Safe Words & Signals', type: 'list', items: ['Red - Stop immediately', 'Yellow - Slow down/check in', 'Green - All is well'] }
                        ]
                    },
                    {
                        type: 'discipline',
                        title: 'Discipline & Correction',
                        fields: [
                            { label: 'Rewards for Obedience & Service', type: 'list', items: ['Praise and affection', 'Special privileges', 'Quality time and attention'] },
                            { label: 'Punishments for Disobedience & Failure', type: 'list', items: ['Loss of privileges', 'Corner time or reflection', 'Physical correction as appropriate'] }
                        ]
                    },
                    {
                        type: 'terms',
                        title: 'Terms of Ownership',
                        fields: [
                            { label: 'Effective Date', type: 'text', value: new Date().toISOString().split('T')[0] },
                            { label: 'Duration of Control', type: 'textarea', value: 'Ongoing and indefinite, subject to review at Dominant\'s discretion' },
                            { label: 'Review Schedule', type: 'textarea', value: 'Contract terms may be reviewed and modified by the Dominant as needed' },
                            { label: 'Release Clause', type: 'textarea', value: 'Either party may terminate this agreement with proper communication. The Dominant retains final authority over the terms of separation' }
                        ]
                    }
                ];

                currentContract.data = { sections: defaultSections };
                saveContract();
            }

            sectionsContainer.innerHTML = currentContract.data.sections.map((section, index) =>
                renderSection(section, index)
            ).join('');

            setupSectionListeners();
        }

        function renderSection(section, index) {
            return `
                <div class="contract-section" data-section-index="${index}">
                    <div class="section-header">
                        <h2 contenteditable="true" data-field="title">${section.title}</h2>
                        <div class="section-actions">
                            <button class="btn btn-secondary" onclick="addField(${index})">+ Add Field</button>
                            <button class="btn btn-secondary remove-btn" onclick="removeSection(${index})">Remove</button>
                        </div>
                    </div>
                    <div class="section-content" data-section-content="${index}">
                        ${section.fields.map((field, fieldIndex) => renderField(field, index, fieldIndex)).join('')}
                    </div>
                </div>
            `;
        }

        function renderField(field, sectionIndex, fieldIndex) {
            const fieldTypes = {
                text: (f) => `<input type="text" value="${f.value || ''}" data-field-value>`,
                textarea: (f) => `<textarea data-field-value>${f.value || ''}</textarea>`,
                list: (f) => `
                    <div class="list-container">
                        ${(f.items || []).map((item, itemIndex) => `
                            <div class="list-item" data-item-index="${itemIndex}">
                                <span class="drag-handle" draggable="true">🎀</span>
                                <input type="text" value="${item || ''}" data-item-index="${itemIndex}">
                                <button class="remove-btn" onclick="removeListItem(${sectionIndex}, ${fieldIndex}, ${itemIndex})">✕</button>
                            </div>
                        `).join('')}
                        <button class="add-item-btn" onclick="addListItem(${sectionIndex}, ${fieldIndex})">+ Add Item</button>
                    </div>
                `
            };

            const fieldType = field.type || 'textarea';
            const renderFunc = fieldTypes[fieldType] || fieldTypes.textarea;

            // For list fields, don't show the parent field bow or make it draggable
            if (fieldType === 'list') {
                return `
                    <div class="field-group field-group-list" data-field-index="${fieldIndex}">
                        <label contenteditable="true" data-field-label>${field.label || 'Field'}</label>
                        ${renderFunc(field)}
                        <button class="remove-btn" onclick="removeField(${sectionIndex}, ${fieldIndex})" style="margin-top: 10px;">Remove Field</button>
                    </div>
                `;
            }

            // For non-list fields, show bow and make only the drag handle draggable
            return `
                <div class="field-group" data-field-index="${fieldIndex}">
                    <span class="drag-handle" draggable="true">🎀</span>
                    <label contenteditable="true" data-field-label>${field.label || 'Field'}</label>
                    ${renderFunc(field)}
                    <button class="remove-btn" onclick="removeField(${sectionIndex}, ${fieldIndex})" style="margin-top: 10px;">Remove Field</button>
                </div>
            `;
        }

        // Field management functions
        window.addField = function(sectionIndex) {
            captureStateForUndo('Add field');
            collectFormData(); // Capture any unsaved changes first
            const sections = currentContract.data.sections;
            sections[sectionIndex].fields.push({
                label: 'New Field',
                type: 'textarea',
                value: ''
            });
            saveContract();
            renderContractEditor();
        };

        window.removeField = function(sectionIndex, fieldIndex) {
            captureStateForUndo('Remove field');
            collectFormData(); // Capture any unsaved changes first
            const sections = currentContract.data.sections;
            sections[sectionIndex].fields.splice(fieldIndex, 1);
            saveContract();
            renderContractEditor();
        };

        window.addListItem = function(sectionIndex, fieldIndex) {
            captureStateForUndo('Add list item');
            collectFormData(); // Capture any unsaved changes first
            const sections = currentContract.data.sections;
            const field = sections[sectionIndex].fields[fieldIndex];
            if (!field.items) field.items = [];
            field.items.push('');
            saveContract();
            renderContractEditor();
        };

        window.removeListItem = function(sectionIndex, fieldIndex, itemIndex) {
            captureStateForUndo('Remove list item');
            collectFormData(); // Capture any unsaved changes first
            const sections = currentContract.data.sections;
            const field = sections[sectionIndex].fields[fieldIndex];
            field.items.splice(itemIndex, 1);
            saveContract();
            renderContractEditor();
        };

        window.removeSection = function(sectionIndex) {
            if (!confirm('Remove this section?')) return;
            captureStateForUndo('Remove section');
            collectFormData(); // Capture any unsaved changes first
            currentContract.data.sections.splice(sectionIndex, 1);
            saveContract();
            renderContractEditor();
        };

        document.getElementById('add-section-btn').addEventListener('click', () => {
            captureStateForUndo('Add section');
            collectFormData(); // Capture any unsaved changes first
            currentContract.data.sections.push({
                type: 'custom',
                title: 'New Section',
                fields: []
            });
            saveContract();
            renderContractEditor();
        });

        // Setup input listeners for auto-save
        let sectionListenersSetup = false; // Track if listeners are already set up

        function setupSectionListeners() {
            // Only set up listeners once to avoid duplicates
            if (sectionListenersSetup) {
                console.log('⏭️ Section listeners already set up, skipping');
                return;
            }

            const editor = document.getElementById('contract-sections');

            // Debounced state capture for text edits (longer delay than save)
            let textEditTimeout = null;
            let hasUncapturedEdits = false;

            editor.addEventListener('input', (e) => {
                const target = e.target;

                if (target.hasAttribute('contenteditable')) {
                    // Handle contenteditable fields (titles, labels)
                    debouncedSave();
                    hasUncapturedEdits = true;
                } else if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                    // Handle regular input fields
                    debouncedSave();
                    hasUncapturedEdits = true;
                }

                // Capture state after user stops typing for 2 seconds
                clearTimeout(textEditTimeout);
                textEditTimeout = setTimeout(() => {
                    if (hasUncapturedEdits) {
                        captureStateForUndo('Text edit');
                        hasUncapturedEdits = false;
                    }
                }, 2000);
            });

            // Setup drag-and-drop for fields
            setupFieldDragDrop();
            // Setup drag-and-drop for list items
            setupListItemDragDrop();

            sectionListenersSetup = true;
            console.log('✅ Section listeners set up');
        }

        // Drag and drop for fields
        let draggedFieldElement = null;
        let draggedFieldSectionIndex = null;

        function setupFieldDragDrop() {
            const editor = document.getElementById('contract-sections');

            editor.addEventListener('dragstart', (e) => {
                // Only allow dragging if the drag handle itself is being dragged
                if (!e.target.classList.contains('drag-handle')) {
                    e.preventDefault();
                    return;
                }

                const fieldGroup = e.target.closest('.field-group');
                if (fieldGroup) {
                    draggedFieldElement = fieldGroup;
                    const section = fieldGroup.closest('.contract-section');
                    draggedFieldSectionIndex = parseInt(section.dataset.sectionIndex);
                    fieldGroup.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                }
            });

            editor.addEventListener('dragend', (e) => {
                const fieldGroup = e.target.closest('.field-group');
                if (fieldGroup) {
                    fieldGroup.classList.remove('dragging');
                    draggedFieldElement = null;
                    draggedFieldSectionIndex = null;
                }
            });

            editor.addEventListener('dragover', (e) => {
                e.preventDefault();
                const fieldGroup = e.target.closest('.field-group');
                if (!fieldGroup || fieldGroup === draggedFieldElement) return;

                const section = fieldGroup.closest('.contract-section');
                const sectionIndex = parseInt(section.dataset.sectionIndex);

                // Only allow dragging within same section
                if (sectionIndex !== draggedFieldSectionIndex) return;

                const rect = fieldGroup.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;

                if (e.clientY < midpoint) {
                    fieldGroup.parentNode.insertBefore(draggedFieldElement, fieldGroup);
                } else {
                    fieldGroup.parentNode.insertBefore(draggedFieldElement, fieldGroup.nextSibling);
                }
            });

            editor.addEventListener('drop', (e) => {
                e.preventDefault();
                if (!draggedFieldElement) return;

                // Capture state before reorder
                captureStateForUndo('Reorder fields');

                // Collect the new order and save
                collectFormData();
                saveContract();
            });
        }

        // Drag and drop for list items
        let draggedListItem = null;
        let draggedListContainer = null;

        function setupListItemDragDrop() {
            const editor = document.getElementById('contract-sections');

            editor.addEventListener('dragstart', (e) => {
                // Only allow dragging if the drag handle itself is being dragged
                if (!e.target.classList.contains('drag-handle')) {
                    e.preventDefault();
                    return;
                }

                const listItem = e.target.closest('.list-item');
                if (listItem) {
                    draggedListItem = listItem;
                    draggedListContainer = listItem.closest('.list-container');
                    listItem.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                }
            });

            editor.addEventListener('dragend', (e) => {
                const listItem = e.target.closest('.list-item');
                if (listItem) {
                    listItem.classList.remove('dragging');
                    draggedListItem = null;
                    draggedListContainer = null;
                }
            });

            editor.addEventListener('dragover', (e) => {
                e.preventDefault();
                const listItem = e.target.closest('.list-item');
                if (!listItem || listItem === draggedListItem) return;

                const container = listItem.closest('.list-container');
                if (container !== draggedListContainer) return; // Only within same list

                const rect = listItem.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;

                if (e.clientY < midpoint) {
                    listItem.parentNode.insertBefore(draggedListItem, listItem);
                } else {
                    listItem.parentNode.insertBefore(draggedListItem, listItem.nextSibling);
                }
            });

            editor.addEventListener('drop', (e) => {
                e.preventDefault();
                if (!draggedListItem) return;

                // Capture state before reorder
                captureStateForUndo('Reorder list items');

                // Collect the new order and save
                collectFormData();
                saveContract();
            });
        }

        document.getElementById('contract-title').addEventListener('input', (e) => {
            currentContract.title = e.target.value;
            // Update the display title
            const displayTitle = document.getElementById('contract-display-title');
            if (displayTitle) {
                displayTitle.textContent = e.target.value || 'D/s Dynamic Contract';
            }
            debouncedSave();
        });

        // Name field event listeners
        document.getElementById('dominant-name').addEventListener('input', (e) => {
            currentContract.dominant_name = e.target.value;
            debouncedSave();
        });

        document.getElementById('submissive-name').addEventListener('input', (e) => {
            currentContract.submissive_name = e.target.value;
            debouncedSave();
        });

        // Signature field event listeners
        ['owner-signature', 'owner-signature-date', 'submissive-signature', 'submissive-signature-date'].forEach(id => {
            document.getElementById(id).addEventListener('input', debouncedSave);
        });

        // Debounced save function
        function debouncedSave() {
            // Don't save if we're currently applying a remote update
            if (isApplyingRemoteUpdate) {
                console.log('⏭️ Skipping save - applying remote update');
                return;
            }

            clearTimeout(saveTimeout);
            updateSyncStatus('syncing');

            saveTimeout = setTimeout(() => {
                collectFormData();
                saveContract();
            }, 600); // 600ms gives users time to finish fast typing before saving
        }

        // Collect form data from DOM
        function collectFormData() {
            const sections = [];
            document.querySelectorAll('.contract-section').forEach(sectionEl => {
                const sectionIndex = parseInt(sectionEl.dataset.sectionIndex);
                const section = currentContract.data.sections[sectionIndex];

                // Safety check: skip if section doesn't exist
                if (!section) return;

                // Update section title
                const titleEl = sectionEl.querySelector('[data-field="title"]');
                if (titleEl) {
                    section.title = titleEl.textContent;
                }

                // Update fields
                sectionEl.querySelectorAll('.field-group').forEach(fieldEl => {
                    const fieldIndex = parseInt(fieldEl.dataset.fieldIndex);
                    const field = section.fields[fieldIndex];

                    // Safety check: skip if field doesn't exist
                    if (!field) return;

                    // Update label
                    const labelEl = fieldEl.querySelector('[data-field-label]');
                    if (labelEl) {
                        field.label = labelEl.textContent;
                    }

                    // Update value
                    const valueEl = fieldEl.querySelector('[data-field-value]');
                    if (valueEl) {
                        field.value = valueEl.value;
                    }

                    // Update list items - only select input elements to avoid selecting parent divs
                    const listItems = fieldEl.querySelectorAll('input[data-item-index]');
                    if (listItems.length > 0) {
                        // Replace the array entirely to avoid stale items
                        field.items = Array.from(listItems).map(item => item.value);
                    } else if (field.type === 'list') {
                        // If it's a list field but has no items, ensure it's an empty array
                        field.items = [];
                    }
                });

                sections.push(section);
            });

            currentContract.data.sections = sections;
        }

        // Save contract to database
        async function saveContract() {
            if (isSyncing) {
                console.log('⏭️ Save already in progress, skipping...');
                return;
            }
            isSyncing = true;
            lastSaveTimestamp = Date.now();

            console.log('💾 Starting save to database...', {
                contractId: currentContract.id,
                timestamp: new Date(lastSaveTimestamp).toLocaleTimeString()
            });

            // Collect signature data
            const ownerSig = document.getElementById('owner-signature')?.value || '';
            const ownerDate = document.getElementById('owner-signature-date')?.value || null;
            const subSig = document.getElementById('submissive-signature')?.value || '';
            const subDate = document.getElementById('submissive-signature-date')?.value || null;

            // Fetch the current state from database for change detection (before we update it)
            // Use * to fetch all columns, avoiding issues with missing columns
            const { data: currentDbState, error: fetchError } = await supabaseClient
                .from('contracts')
                .select('*')
                .eq('id', currentContract.id)
                .single();

            if (fetchError) {
                console.warn('⚠️ Could not fetch current state for change tracking:', fetchError);
            }

            // Build previous contract state for comparison
            const previousContract = currentDbState || null;

            // Build new contract state for comparison (only include what we're comparing)
            const newContract = {
                title: currentContract.title,
                data: currentContract.data,
                owner_signature: ownerSig,
                submissive_signature: subSig
            };

            // Include name fields only if they exist in the database schema
            if (currentDbState && 'dominant_name' in currentDbState) {
                newContract.dominant_name = currentContract.dominant_name;
                newContract.submissive_name = currentContract.submissive_name;
            }

            // Generate change description
            const changeDescription = generateChangeDescription(previousContract, newContract);

            // Build update object - only include fields that exist in database
            const updateData = {
                title: currentContract.title,
                data: currentContract.data,
                owner_signature: ownerSig,
                owner_signature_date: ownerDate,
                submissive_signature: subSig,
                submissive_signature_date: subDate
                // Don't set updated_at manually - let the DB trigger handle it
            };

            // Include name fields only if they exist in the database schema
            if (currentDbState && 'dominant_name' in currentDbState) {
                updateData.dominant_name = currentContract.dominant_name;
                updateData.submissive_name = currentContract.submissive_name;
            }

            const { data: updatedData, error } = await supabaseClient
                .from('contracts')
                .update(updateData)
                .eq('id', currentContract.id)
                .select()
                .single();

            if (error) {
                console.error('❌ Error saving contract:', error);
                updateSyncStatus('error');
            } else {
                console.log('✅ Save completed successfully - UPDATE sent to database');

                // Update local copy with signatures and updated_at from the DB response
                currentContract.owner_signature = ownerSig;
                currentContract.owner_signature_date = ownerDate;
                currentContract.submissive_signature = subSig;
                currentContract.submissive_signature_date = subDate;
                const newUpdatedAt = updatedData.updated_at;
                currentContract.updated_at = newUpdatedAt;

                // Wait 150ms before broadcasting to ensure DB commit completes
                // This prevents race conditions where broadcast arrives before DB is ready
                await new Promise(resolve => setTimeout(resolve, 150));

                // Broadcast update to other clients
                if (realtimeChannel) {
                    console.log('📡 Broadcasting update to other clients...');
                    await realtimeChannel.send({
                        type: 'broadcast',
                        event: 'contract-updated',
                        payload: {
                            userId: currentUser?.id,
                            timestamp: Date.now(),
                            updatedAt: newUpdatedAt // Send expected updated_at for validation
                        }
                    });
                    console.log('📡 Broadcast sent successfully');
                }

                updateSyncStatus('synced');
                // Track change in history with meaningful description
                await trackChange('updated', changeDescription);
            }

            isSyncing = false;
            console.log('💾 Save process complete, isSyncing reset to false');
        }

        // ============================================
        // REALTIME SYNC
        // ============================================

        function setupRealtimeSync() {
            console.log('🔧 Setting up realtime sync for contract:', currentContract.id);

            // Clean up existing connections
            if (realtimeChannel) {
                console.log('🧹 Cleaning up existing realtime channel');
                supabaseClient.removeChannel(realtimeChannel);
            }
            if (pollingInterval) {
                console.log('🧹 Cleaning up existing polling interval');
                clearInterval(pollingInterval);
                pollingInterval = null;
            }

            // Use Broadcast channel (doesn't require database replication to be enabled)
            // This works even when Realtime replication is restricted/beta
            realtimeChannel = supabaseClient
                .channel(`contract-sync:${currentContract.id}`)
                .on('broadcast', { event: 'contract-updated' }, async (payload) => {
                    console.log('📡 Broadcast received:', payload);
                    console.log('   Channel state:', realtimeChannel?.state);
                    console.log('   Channel topic:', realtimeChannel?.topic);
                    await handleBroadcastUpdate(payload);
                })
                .subscribe((status, err) => {
                    console.log('📡 Broadcast channel status:', status);
                    if (err) console.error('📡 Broadcast channel error:', err);

                    if (status === 'SUBSCRIBED') {
                        console.log('✅ Broadcast sync enabled - listening for updates to contract:', currentContract.id);
                        console.log('   Channel ID:', realtimeChannel?.topic);
                        console.log('   Channel state:', realtimeChannel?.state);
                        usePolling = false;
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.log('⚠️ Broadcast not available, using polling fallback');
                        usePolling = true;
                        setupPollingSync();
                    } else {
                        console.log('📡 Channel status changed to:', status);
                    }
                });

            // Also start polling as a backup (will check usePolling flag)
            setTimeout(() => {
                if (!realtimeChannel || realtimeChannel.state !== 'joined') {
                    console.log('⚠️ Realtime failed to connect, using polling fallback');
                    usePolling = true;
                    setupPollingSync();
                }
            }, 3000); // Wait 3 seconds for realtime to connect
        }

        function setupPollingSync() {
            if (pollingInterval) return; // Already polling

            // Poll every 3 seconds for changes
            pollingInterval = setInterval(async () => {
                // Don't skip polling - we need to catch updates even during saves
                // The timestamp-based echo detection will prevent infinite loops

                try {
                    const { data, error } = await supabaseClient
                        .from('contracts')
                        .select('*')
                        .eq('id', currentContract.id)
                        .single();

                    if (error) {
                        console.error('Polling error:', error);
                        return;
                    }

                    // Check if data changed (any field)
                    const dataChanged = data && JSON.stringify(data.data) !== JSON.stringify(currentContract.data);
                    const titleChanged = data && data.title !== currentContract.title;
                    // Only check name fields if they exist in the database
                    const dominantChanged = data && ('dominant_name' in data) &&
                                           data.dominant_name !== currentContract.dominant_name;
                    const submissiveChanged = data && ('submissive_name' in data) &&
                                             data.submissive_name !== currentContract.submissive_name;

                    if (dataChanged || titleChanged || dominantChanged || submissiveChanged) {
                        console.log('📥 Polling detected changes');

                        // Set flag to prevent auto-save during update
                        isApplyingRemoteUpdate = true;

                        try {
                            // Update contract data with selective updates
                            const oldContract = JSON.parse(JSON.stringify(currentContract));
                            currentContract = data;
                            updateFieldsSelectively(oldContract, data);
                            updateSyncStatus('synced');

                            // Show notification
                            showSyncNotification('Contract updated by another user');
                        } finally {
                            isApplyingRemoteUpdate = false;
                        }
                    }
                } catch (err) {
                    console.error('Polling failed:', err);
                }
            }, 3000); // Poll every 3 seconds

            console.log('🔄 Polling sync active (checking every 3 seconds)');
        }

        // Handle broadcast updates (client-to-client messaging)
        async function handleBroadcastUpdate(payload) {
            try {
                console.log('🔔 Broadcast update received!', {
                    timestamp: new Date().toLocaleTimeString(),
                    payload: payload.payload
                });

                const { userId, timestamp: updateTimestamp, updatedAt: expectedUpdatedAt } = payload.payload || {};

                // Ignore our own broadcasts
                if (userId === currentUser?.id) {
                    console.log('📤 Ignoring our own broadcast');
                    return;
                }

                // Ignore if we just saved recently (within 500ms)
                const timeSinceLastSave = Date.now() - lastSaveTimestamp;
                if (timeSinceLastSave < 500) {
                    console.log('📤 Ignoring broadcast - just saved', { timeSinceLastSave: timeSinceLastSave + 'ms' });
                    return;
                }

                console.log('📥 Fetching latest contract data from database...');

            // Fetch with retry logic (max 3 attempts with exponential backoff)
            let latestData = null;
            let attempts = 0;
            const maxAttempts = 3;

            while (attempts < maxAttempts) {
                attempts++;

                try {
                    const { data, error } = await supabaseClient
                        .from('contracts')
                        .select('*')
                        .eq('id', currentContract.id)
                        .single();

                    if (error) {
                        console.error(`❌ Error fetching contract (attempt ${attempts}/${maxAttempts}):`, error);
                        if (attempts < maxAttempts) {
                            const delay = Math.pow(2, attempts) * 100; // 200ms, 400ms, 800ms
                            console.log(`⏳ Retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        return;
                    }

                    // Check if we got the expected update (by updated_at timestamp)
                    // Allow for slight timing differences (within 1 second) due to clock skew
                    const isExpectedUpdate = !expectedUpdatedAt ||
                                            Math.abs(new Date(data.updated_at) - new Date(expectedUpdatedAt)) < 1000;

                    if (!isExpectedUpdate && attempts < maxAttempts) {
                        console.log(`⏳ Data seems stale (expected: ${expectedUpdatedAt}, got: ${data.updated_at}, diff: ${new Date(data.updated_at) - new Date(expectedUpdatedAt)}ms), retrying...`);
                        const delay = Math.pow(2, attempts) * 100;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    latestData = data;
                    break;

                } catch (err) {
                    console.error(`❌ Fetch error (attempt ${attempts}/${maxAttempts}):`, err);
                    if (attempts < maxAttempts) {
                        const delay = Math.pow(2, attempts) * 100;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    return;
                }
            }

            if (!latestData) {
                console.error('❌ Failed to fetch latest contract after all retries');
                return;
            }

            // Check if data actually changed
            const dataChanged = JSON.stringify(latestData.data) !== JSON.stringify(currentContract.data);
            const titleChanged = latestData.title !== currentContract.title;
            // Only check name fields if they exist in the database
            const dominantChanged = ('dominant_name' in latestData) &&
                                   latestData.dominant_name !== currentContract.dominant_name;
            const submissiveChanged = ('submissive_name' in latestData) &&
                                     latestData.submissive_name !== currentContract.submissive_name;

            console.log('🔍 Checking for changes:', {
                dataChanged,
                titleChanged,
                dominantChanged,
                submissiveChanged,
                attempts: attempts,
                updatedAt: latestData.updated_at
            });

            if (dataChanged || titleChanged || dominantChanged || submissiveChanged) {
                console.log('📥 APPLYING UPDATE from another user/device');

                // Set flag to prevent auto-save during update
                isApplyingRemoteUpdate = true;

                try {
                    // Update contract data
                    const oldContract = JSON.parse(JSON.stringify(currentContract));
                    currentContract = latestData;

                    // Smart selective update that preserves focus
                    updateFieldsSelectively(oldContract, latestData);

                    updateSyncStatus('synced');

                    // Show notification that data was updated
                    showSyncNotification('Contract updated by another user');
                } finally {
                    // Always reset flag, even if error occurs
                    isApplyingRemoteUpdate = false;
                    console.log('✅ Remote update applied, auto-save re-enabled');
                }
            } else {
                console.log('⏭️ No changes detected after', attempts, 'attempts');
            }
            } catch (error) {
                console.error('❌ Error in handleBroadcastUpdate:', error);
                console.error('   Error stack:', error.stack);
                // Don't throw - we want the channel to stay alive for future updates
            }
        }

        function handleRealtimeUpdate(payload) {
            console.log('🔔 Realtime update received!', {
                event: payload.eventType,
                timestamp: new Date().toLocaleTimeString()
            });

            const newData = payload.new;

            // Only ignore if this is our own update echoing back within 2 seconds
            const timeSinceLastSave = Date.now() - lastSaveTimestamp;
            const isOurOwnUpdate = isSyncing && timeSinceLastSave < 2000 &&
                                  JSON.stringify(newData.data) === JSON.stringify(currentContract.data);

            if (isOurOwnUpdate) {
                console.log('📤 Ignoring our own update echo', {
                    timeSinceLastSave: timeSinceLastSave + 'ms',
                    isSyncing
                });
                return;
            }

            // Check if data actually changed
            const dataChanged = JSON.stringify(newData.data) !== JSON.stringify(currentContract.data);
            const titleChanged = newData.title !== currentContract.title;
            // Only check name fields if they exist in the database
            const dominantChanged = ('dominant_name' in newData) &&
                                   newData.dominant_name !== currentContract.dominant_name;
            const submissiveChanged = ('submissive_name' in newData) &&
                                     newData.submissive_name !== currentContract.submissive_name;

            console.log('🔍 Checking for changes:', {
                dataChanged,
                titleChanged,
                dominantChanged,
                submissiveChanged,
                timeSinceLastSave: timeSinceLastSave + 'ms',
                isSyncing
            });

            if (dataChanged || titleChanged || dominantChanged || submissiveChanged) {
                console.log('📥 APPLYING UPDATE from another user/device');

                // Set flag to prevent auto-save during update
                isApplyingRemoteUpdate = true;

                try {
                    // Update contract data
                    const oldContract = JSON.parse(JSON.stringify(currentContract));
                    currentContract = newData;

                    // Smart selective update that preserves focus
                    updateFieldsSelectively(oldContract, newData);

                    updateSyncStatus('synced');

                    // Show notification that data was updated
                    showSyncNotification('Contract updated by another user');
                } finally {
                    isApplyingRemoteUpdate = false;
                }
            } else {
                console.log('⏭️ No changes detected, skipping update');
            }
        }

        function updateFieldsSelectively(oldContract, newContract) {
            console.log('🔧 updateFieldsSelectively called');

            // Get currently focused element to preserve it
            const focusedElement = document.activeElement;
            const focusedField = focusedElement?.dataset?.fieldValue !== undefined ||
                                focusedElement?.dataset?.fieldLabel !== undefined ||
                                focusedElement?.dataset?.itemIndex !== undefined;

            // If user is typing in a field, don't interrupt them
            const preserveFocus = focusedField &&
                                (focusedElement.tagName === 'INPUT' ||
                                 focusedElement.tagName === 'TEXTAREA' ||
                                 focusedElement.isContentEditable);

            console.log('   Focused element:', focusedElement?.tagName, focusedElement?.id);
            console.log('   Preserve focus:', preserveFocus);

            // Update title if changed
            const titleInput = document.getElementById('contract-title');
            if (titleInput && newContract.title !== oldContract.title) {
                const isFocused = document.activeElement === titleInput;

                // If focused, only update if current value matches what we expect
                if (isFocused && titleInput.value !== oldContract.title) {
                    console.log('   ⏭️ Skipping title update - user has typed more');
                } else {
                    console.log('   Updating title:', oldContract.title, '→', newContract.title);
                    const cursorStart = isFocused ? titleInput.selectionStart : null;
                    const cursorEnd = isFocused ? titleInput.selectionEnd : null;

                    titleInput.value = newContract.title || '';
                    document.getElementById('contract-display-title').textContent = newContract.title || 'D/s Dynamic Contract';

                    if (isFocused && cursorStart !== null) {
                        titleInput.setSelectionRange(cursorStart, cursorEnd);
                    }
                }
            }

            // Update dominant name if changed (only if field exists in DB)
            const dominantInput = document.getElementById('dominant-name');
            if (dominantInput &&
                'dominant_name' in newContract && 'dominant_name' in oldContract &&
                newContract.dominant_name !== oldContract.dominant_name) {
                const isFocused = document.activeElement === dominantInput;

                // If focused, only update if current value matches what we expect
                if (isFocused && dominantInput.value !== oldContract.dominant_name) {
                    console.log('   ⏭️ Skipping dominant name update - user has typed more');
                } else {
                    const cursorStart = isFocused ? dominantInput.selectionStart : null;
                    const cursorEnd = isFocused ? dominantInput.selectionEnd : null;

                    dominantInput.value = newContract.dominant_name || '';

                    if (isFocused && cursorStart !== null) {
                        dominantInput.setSelectionRange(cursorStart, cursorEnd);
                    }
                }
            }

            // Update submissive name if changed (only if field exists in DB)
            const submissiveInput = document.getElementById('submissive-name');
            if (submissiveInput &&
                'submissive_name' in newContract && 'submissive_name' in oldContract &&
                newContract.submissive_name !== oldContract.submissive_name) {
                const isFocused = document.activeElement === submissiveInput;

                // If focused, only update if current value matches what we expect
                if (isFocused && submissiveInput.value !== oldContract.submissive_name) {
                    console.log('   ⏭️ Skipping submissive name update - user has typed more');
                } else {
                    const cursorStart = isFocused ? submissiveInput.selectionStart : null;
                    const cursorEnd = isFocused ? submissiveInput.selectionEnd : null;

                    submissiveInput.value = newContract.submissive_name || '';

                    if (isFocused && cursorStart !== null) {
                        submissiveInput.setSelectionRange(cursorStart, cursorEnd);
                    }
                }
            }

            // Check if sections structure changed (added/removed sections or fields)
            const oldSections = oldContract.data?.sections || [];
            const newSections = newContract.data?.sections || [];

            const structureChanged = oldSections.length !== newSections.length ||
                                   oldSections.some((s, i) =>
                                       !newSections[i] ||
                                       s.fields.length !== newSections[i].fields.length
                                   );

            console.log('   Structure changed:', structureChanged);
            console.log('   Old sections:', oldSections.length, 'New sections:', newSections.length);

            if (structureChanged) {
                console.log('   ⚠️ Structure changed - doing full re-render');
                // Full re-render if structure changed, but try to preserve focus
                const focusPath = preserveFocus ? getFocusPath(focusedElement) : null;
                renderContractEditor();
                if (focusPath) {
                    restoreFocus(focusPath);
                }
                return;
            }

            console.log('   📝 Selectively updating', newSections.length, 'sections');

            // Selectively update field values without full re-render
            let fieldsUpdated = 0;
            newSections.forEach((section, sectionIndex) => {
                const oldSection = oldSections[sectionIndex];
                if (!oldSection) return;

                // Update section title if changed
                const sectionHeader = document.querySelector(`[data-section-index="${sectionIndex}"] h2`);
                if (sectionHeader &&
                    section.title !== oldSection.title &&
                    document.activeElement !== sectionHeader) {
                    sectionHeader.textContent = section.title;
                }

                // Update fields
                section.fields.forEach((field, fieldIndex) => {
                    const oldField = oldSection.fields[fieldIndex];
                    if (!oldField) return;

                    // Update field label
                    const labelElement = document.querySelector(
                        `[data-section-index="${sectionIndex}"] [data-field-index="${fieldIndex}"] label[data-field-label]`
                    );
                    if (labelElement &&
                        field.label !== oldField.label &&
                        document.activeElement !== labelElement) {
                        labelElement.textContent = field.label;
                    }

                    // Update field value based on type
                    if (field.type === 'list') {
                        // Update list items
                        const listItems = field.items || [];
                        const oldListItems = oldField.items || [];

                        // If list length changed, re-render the whole section
                        if (listItems.length !== oldListItems.length) {
                            console.log('      List length changed, re-rendering');
                            const focusPath = preserveFocus ? getFocusPath(focusedElement) : null;
                            renderContractEditor();
                            if (focusPath) {
                                restoreFocus(focusPath);
                            }
                            return;
                        }

                        // Update individual list items
                        listItems.forEach((item, itemIndex) => {
                            const itemInput = document.querySelector(
                                `[data-section-index="${sectionIndex}"] [data-field-index="${fieldIndex}"] input[data-item-index="${itemIndex}"]`
                            );
                            if (item !== oldListItems[itemIndex]) {
                                console.log(`      List item [${sectionIndex}][${fieldIndex}][${itemIndex}] changed:`, oldListItems[itemIndex], '→', item, 'Found element:', !!itemInput);
                            }
                            if (itemInput && item !== oldListItems[itemIndex]) {
                                // Check if this field is focused
                                const isFocused = document.activeElement === itemInput;

                                // If focused, only update if current value matches what we expect
                                if (isFocused) {
                                    const currentValue = itemInput.value;
                                    const expectedValue = oldListItems[itemIndex] || '';
                                    if (currentValue !== expectedValue) {
                                        console.log(`      ⏭️ Skipping focused list item [${sectionIndex}][${fieldIndex}][${itemIndex}] - user has typed more`);
                                        return; // User has typed more, don't overwrite
                                    }
                                }

                                // Save cursor position if this field is focused
                                const cursorStart = isFocused ? itemInput.selectionStart : null;
                                const cursorEnd = isFocused ? itemInput.selectionEnd : null;

                                // Update the value
                                itemInput.value = item || '';
                                fieldsUpdated++;
                                console.log(`      ✅ Updated list item [${sectionIndex}][${fieldIndex}][${itemIndex}]${isFocused ? ' (focused, cursor restored)' : ''}`);

                                // Restore cursor position if it was focused
                                if (isFocused && cursorStart !== null) {
                                    itemInput.setSelectionRange(cursorStart, cursorEnd);
                                }
                            }
                        });
                    } else {
                        // Update text or textarea field
                        const fieldInput = document.querySelector(
                            `[data-section-index="${sectionIndex}"] [data-field-index="${fieldIndex}"] [data-field-value]`
                        );
                        if (field.value !== oldField.value) {
                            console.log(`      Field [${sectionIndex}][${fieldIndex}] changed:`, oldField.value?.substring(0, 50), '→', field.value?.substring(0, 50), 'Found element:', !!fieldInput);
                        }
                        if (fieldInput && field.value !== oldField.value) {
                            // Check if this field is focused
                            const isFocused = document.activeElement === fieldInput;

                            // If focused, only update if current value matches what we expect (oldField)
                            // This prevents overwriting if user has typed more since the save
                            if (isFocused) {
                                const currentValue = fieldInput.value;
                                if (currentValue !== oldField.value) {
                                    console.log(`      ⏭️ Skipping focused field [${sectionIndex}][${fieldIndex}] - user has typed more (expected: "${oldField.value?.substring(0, 30)}", current: "${currentValue?.substring(0, 30)}")`);
                                    return; // User has typed more, don't overwrite
                                }
                            }

                            // Save cursor position if this field is focused
                            const cursorStart = isFocused ? fieldInput.selectionStart : null;
                            const cursorEnd = isFocused ? fieldInput.selectionEnd : null;

                            // Update the value
                            if (fieldInput.tagName === 'INPUT' || fieldInput.tagName === 'TEXTAREA') {
                                fieldInput.value = field.value || '';
                                fieldsUpdated++;
                                console.log(`      ✅ Updated field [${sectionIndex}][${fieldIndex}]${isFocused ? ' (focused, cursor restored)' : ''}`);
                            }

                            // Restore cursor position if it was focused
                            if (isFocused && cursorStart !== null) {
                                fieldInput.setSelectionRange(cursorStart, cursorEnd);
                            }
                        }
                    }
                });
            });

            console.log('   ✅ Updated', fieldsUpdated, 'fields');
        }

        function getFocusPath(element) {
            if (!element) return null;

            // Find the section and field indices
            const section = element.closest('[data-section-index]');
            const field = element.closest('[data-field-index]');
            const item = element.closest('[data-item-index]');

            if (!section) return null;

            const path = {
                sectionIndex: section.dataset.sectionIndex,
                fieldIndex: field?.dataset.fieldIndex,
                itemIndex: item?.dataset.itemIndex,
                tagName: element.tagName,
                selectionStart: element.selectionStart,
                selectionEnd: element.selectionEnd,
                isContentEditable: element.isContentEditable
            };

            return path;
        }

        function restoreFocus(path) {
            if (!path) return;

            try {
                let selector = `[data-section-index="${path.sectionIndex}"]`;

                if (path.fieldIndex !== undefined) {
                    selector += ` [data-field-index="${path.fieldIndex}"]`;
                }

                if (path.itemIndex !== undefined) {
                    selector += ` input[data-item-index="${path.itemIndex}"]`;
                } else if (path.tagName === 'H2') {
                    selector += ' h2';
                } else if (path.tagName === 'LABEL') {
                    selector += ' label[data-field-label]';
                } else {
                    selector += ' [data-field-value]';
                }

                const element = document.querySelector(selector);
                if (element) {
                    element.focus();

                    // Restore cursor position
                    if (element.setSelectionRange && path.selectionStart !== undefined) {
                        element.setSelectionRange(path.selectionStart, path.selectionEnd);
                    }
                }
            } catch (err) {
                console.log('Could not restore focus:', err);
            }
        }

        function showSyncNotification(message) {
            // Create or update sync notification
            let notification = document.getElementById('sync-notification');

            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'sync-notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    background: linear-gradient(135deg, #dc143c, #ff1744);
                    color: white;
                    padding: 12px 18px;
                    border-radius: 10px;
                    box-shadow: 0 4px 20px rgba(220, 20, 60, 0.4);
                    z-index: 10000;
                    font-size: 13px;
                    font-weight: 500;
                    animation: slideInRight 0.3s ease-out;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
                document.body.appendChild(notification);
            }

            notification.innerHTML = `
                <span style="font-size: 16px;">🔄</span>
                <span>${message}</span>
            `;
            notification.style.display = 'flex';

            // Auto-hide after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 300);
            }, 3000);
        }

        function updateSyncStatus(status) {
            const dot = document.getElementById('sync-dot');
            const text = document.getElementById('sync-text');

            dot.className = 'sync-dot';

            switch (status) {
                case 'syncing':
                    dot.classList.add('syncing');
                    text.textContent = 'Syncing...';
                    break;
                case 'synced':
                    text.textContent = 'Synced';
                    break;
                case 'error':
                    dot.classList.add('error');
                    text.textContent = 'Error';
                    break;
            }
        }

        // ============================================
        // PRESENCE (Who's Online)
        // ============================================

        function setupPresence() {
            if (presenceChannel) {
                supabaseClient.removeChannel(presenceChannel);
            }

            // Determine user's role in this contract
            const isEditor = currentUser.isPublicEditor ||
                            currentContract.user_id === currentUser.id ||
                            currentContract.public_share_role === 'editor';

            presenceChannel = supabaseClient.channel(`presence-${currentContract.id}`)
                .on('presence', { event: 'sync' }, () => {
                    const state = presenceChannel.presenceState();
                    updatePresenceUI(state);
                })
                .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                    console.log('User joined:', newPresences);
                    showJoinNotification(newPresences[0]);
                })
                .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                    console.log('User left:', leftPresences);
                })
                .subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        await presenceChannel.track({
                            user: currentUser.email,
                            display_name: currentUserProfile?.display_name || null,
                            mode: isEditor ? 'editing' : 'viewing',
                            isPublicUser: currentUser.isPublicEditor || false,
                            online_at: new Date().toISOString()
                        });
                    }
                });
        }

        function updatePresenceUI(state) {
            const users = Object.values(state).flat();
            const currentUserEmail = currentUser.email;
            const otherUsers = users.filter(u => u.user !== currentUserEmail);

            // Count editors and viewers
            const editors = users.filter(u => u.mode === 'editing');
            const viewers = users.filter(u => u.mode === 'viewing');
            const otherEditors = editors.filter(u => u.user !== currentUserEmail);

            // Update presence count in main header
            const presenceCount = document.getElementById('presence-count');
            if (presenceCount) {
                presenceCount.textContent = `${users.length} online`;
            }

            // Update presence count in preview header
            const previewPresenceCount = document.getElementById('preview-presence-count');
            if (previewPresenceCount) {
                previewPresenceCount.textContent = `${users.length} online`;
            }

            // Show presence section in preview if open
            const previewOverlay = document.getElementById('preview-overlay');
            const previewPresenceSection = document.getElementById('preview-presence-section');
            if (previewOverlay && previewOverlay.classList.contains('open') && previewPresenceSection) {
                previewPresenceSection.style.display = 'flex';
            }

            // Show/hide multi-editor badge
            const multiEditorBadge = document.getElementById('multi-editor-badge');
            const multiEditorText = document.getElementById('multi-editor-text');
            if (otherEditors.length > 0) {
                if (multiEditorBadge) multiEditorBadge.style.display = 'inline-flex';
                if (multiEditorText) {
                    const count = otherEditors.length;
                    multiEditorText.textContent = `${count} ${count === 1 ? 'editor' : 'editors'}`;
                }
            } else {
                if (multiEditorBadge) multiEditorBadge.style.display = 'none';
            }

            // Update presence dropdown user list
            updatePresenceDropdownList(users);

            // Clean up old overlapping elements if they exist
            const oldWarning = document.getElementById('multi-editor-warning');
            if (oldWarning) oldWarning.remove();
            const oldList = document.getElementById('presence-detail-list');
            if (oldList) oldList.remove();
        }

        function updatePresenceDropdownList(users) {
            const listEl = document.getElementById('presence-user-list');
            if (!listEl) return;

            const currentUserEmail = currentUser.email;

            const html = users.map(u => {
                const isYou = u.user === currentUserEmail;
                const name = u.isPublicUser ? 'Public User' : (u.display_name || u.user.split('@')[0]);
                const modeIcon = u.mode === 'editing' ? '✏️' : '👁️';
                const modeText = u.mode === 'editing' ? 'Editing' : 'Viewing';
                const modeClass = u.mode === 'editing' ? 'editing' : 'viewing';

                return `
                    <div class="presence-user-item ${modeClass}">
                        <div class="presence-user-name ${isYou ? 'you' : ''}">
                            ${name}${isYou ? ' (You)' : ''}
                            <span>${modeIcon}</span>
                        </div>
                        <div class="presence-user-mode ${modeClass}">
                            ${modeText}
                        </div>
                    </div>
                `;
            }).join('');

            listEl.innerHTML = html;
        }

        function showJoinNotification(user) {
            const name = user.isPublicUser ? 'A public user' : (user.display_name || user.user.split('@')[0]);
            const mode = user.mode === 'editing' ? 'editing' : 'viewing';
            const icon = user.mode === 'editing' ? '✏️' : '👁️';

            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(220, 20, 60, 0.95));
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                z-index: 10000;
                animation: slideInRight 0.3s ease-out;
                border: 1px solid var(--accent-pink);
            `;
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 24px;">${icon}</span>
                    <div>
                        <div style="font-weight: 600;">${name} joined</div>
                        <div style="font-size: 12px; opacity: 0.9;">Now ${mode}</div>
                    </div>
                </div>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // ============================================
        // HISTORY TRACKING
        // ============================================

        /**
         * Generate human-friendly description of changes between two contract snapshots
         */
        function generateChangeDescription(oldContract, newContract) {
            const changes = [];

            // Helper function to escape HTML and truncate text
            function formatText(text, maxLength = 60) {
                if (!text) return '';
                const escaped = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                if (escaped.length > maxLength) {
                    return escaped.substring(0, maxLength) + '...';
                }
                return escaped;
            }

            // Helper to format field value for display
            function formatValue(value, maxLength = 80) {
                if (!value) return '(empty)';
                const singleLine = value.replace(/\n+/g, ' ').trim();
                return `"${formatText(singleLine, maxLength)}"`;
            }

            // Compute text diff to show what was added/removed/changed
            function getTextDiff(oldText, newText) {
                oldText = oldText || '';
                newText = newText || '';

                // Simple case: one is empty
                if (!oldText && newText) {
                    return { type: 'added', text: newText };
                }
                if (oldText && !newText) {
                    return { type: 'removed', text: oldText };
                }
                if (oldText === newText) {
                    return { type: 'unchanged' };
                }

                // Check for simple append
                if (newText.startsWith(oldText)) {
                    const added = newText.substring(oldText.length).trim();
                    if (added) {
                        return { type: 'appended', text: added, context: formatText(oldText, 40) };
                    }
                }

                // Check for simple prepend
                if (newText.endsWith(oldText)) {
                    const added = newText.substring(0, newText.length - oldText.length).trim();
                    if (added) {
                        return { type: 'prepended', text: added, context: formatText(oldText, 40) };
                    }
                }

                // Check for simple truncation from end
                if (oldText.startsWith(newText)) {
                    const removed = oldText.substring(newText.length).trim();
                    if (removed) {
                        return { type: 'truncated_end', text: removed, context: formatText(newText, 40) };
                    }
                }

                // Check for simple truncation from beginning
                if (oldText.endsWith(newText)) {
                    const removed = oldText.substring(0, oldText.length - newText.length).trim();
                    if (removed) {
                        return { type: 'truncated_start', text: removed, context: formatText(newText, 40) };
                    }
                }

                // For more complex changes, try word-level diff
                const oldWords = oldText.split(/\s+/);
                const newWords = newText.split(/\s+/);

                // Find common prefix
                let commonPrefixLength = 0;
                while (commonPrefixLength < oldWords.length &&
                       commonPrefixLength < newWords.length &&
                       oldWords[commonPrefixLength] === newWords[commonPrefixLength]) {
                    commonPrefixLength++;
                }

                // Find common suffix
                let commonSuffixLength = 0;
                while (commonSuffixLength < oldWords.length - commonPrefixLength &&
                       commonSuffixLength < newWords.length - commonPrefixLength &&
                       oldWords[oldWords.length - 1 - commonSuffixLength] === newWords[newWords.length - 1 - commonSuffixLength]) {
                    commonSuffixLength++;
                }

                const removedWords = oldWords.slice(commonPrefixLength, oldWords.length - commonSuffixLength);
                const addedWords = newWords.slice(commonPrefixLength, newWords.length - commonSuffixLength);

                if (removedWords.length > 0 && addedWords.length === 0) {
                    // Only removals
                    const context = commonPrefixLength > 0 ? oldWords.slice(Math.max(0, commonPrefixLength - 3), commonPrefixLength).join(' ') : '';
                    return {
                        type: 'removed_words',
                        text: removedWords.join(' '),
                        context: context
                    };
                } else if (addedWords.length > 0 && removedWords.length === 0) {
                    // Only additions
                    const context = commonPrefixLength > 0 ? oldWords.slice(Math.max(0, commonPrefixLength - 3), commonPrefixLength).join(' ') : '';
                    return {
                        type: 'added_words',
                        text: addedWords.join(' '),
                        context: context
                    };
                } else if (removedWords.length > 0 && addedWords.length > 0) {
                    // Replacement
                    return {
                        type: 'replaced',
                        oldText: removedWords.join(' '),
                        newText: addedWords.join(' ')
                    };
                }

                // Fallback: show both values
                return {
                    type: 'changed',
                    oldText: formatText(oldText, 50),
                    newText: formatText(newText, 50)
                };
            }

            // Format diff result into readable text
            function formatDiff(fieldLabel, diff) {
                const label = formatText(fieldLabel);

                switch (diff.type) {
                    case 'added':
                        return `📝 Set "${label}" to ${formatValue(diff.text)}`;

                    case 'removed':
                        return `🗑️ Cleared "${label}" (was ${formatValue(diff.text)})`;

                    case 'appended':
                        return `➕ Added to "${label}": ${formatValue(diff.text)}`;

                    case 'prepended':
                        return `➕ Added at start of "${label}": ${formatValue(diff.text)}`;

                    case 'truncated_end':
                        return `➖ Removed from end of "${label}": ${formatValue(diff.text)}`;

                    case 'truncated_start':
                        return `➖ Removed from start of "${label}": ${formatValue(diff.text)}`;

                    case 'added_words':
                        const addContext = diff.context ? `after "...${diff.context}"` : '';
                        return `➕ Added to "${label}" ${addContext}: ${formatValue(diff.text)}`;

                    case 'removed_words':
                        const remContext = diff.context ? `after "...${diff.context}"` : '';
                        return `➖ Removed from "${label}" ${remContext}: ${formatValue(diff.text)}`;

                    case 'replaced':
                        return `✏️ Changed in "${label}": ${formatValue(diff.oldText)} → ${formatValue(diff.newText)}`;

                    case 'changed':
                        return `✏️ Updated "${label}" from ${formatValue(diff.oldText)} to ${formatValue(diff.newText)}`;

                    case 'unchanged':
                    default:
                        return null;
                }
            }

            // Check title change
            if (oldContract?.title !== newContract.title) {
                const diff = getTextDiff(oldContract?.title || '', newContract.title);
                const diffText = formatDiff('Contract Title', diff);
                if (diffText) {
                    changes.push(diffText);
                }
            }

            // Check signature changes
            if (oldContract?.owner_signature !== newContract.owner_signature) {
                if (newContract.owner_signature && !oldContract?.owner_signature) {
                    changes.push(`✍️ Owner signed the contract`);
                } else if (!newContract.owner_signature && oldContract?.owner_signature) {
                    changes.push('Owner signature removed');
                }
            }
            if (oldContract?.submissive_signature !== newContract.submissive_signature) {
                if (newContract.submissive_signature && !oldContract?.submissive_signature) {
                    changes.push(`✍️ Submissive signed the contract`);
                } else if (!newContract.submissive_signature && oldContract?.submissive_signature) {
                    changes.push('Submissive signature removed');
                }
            }

            // Compare sections
            const oldSections = oldContract?.data?.sections || [];
            const newSections = newContract.data?.sections || [];

            // Detect section additions
            if (newSections.length > oldSections.length) {
                const addedSections = newSections.slice(oldSections.length);
                addedSections.forEach(section => {
                    if (section.title) {
                        changes.push(`➕ Added section: "${formatText(section.title)}"`);
                    }
                });
            }

            // Detect section removals
            if (newSections.length < oldSections.length) {
                const removedSections = oldSections.slice(newSections.length);
                removedSections.forEach(section => {
                    if (section.title) {
                        changes.push(`➖ Removed section: "${formatText(section.title)}"`);
                    }
                });
            }

            // Compare existing sections for modifications
            const minLength = Math.min(oldSections.length, newSections.length);
            for (let i = 0; i < minLength; i++) {
                const oldSection = oldSections[i];
                const newSection = newSections[i];

                // Check section title change
                if (oldSection.title !== newSection.title) {
                    changes.push(`Renamed section from "${formatText(oldSection.title)}" to "${formatText(newSection.title)}"`);
                }

                // Compare fields within section
                const oldFields = oldSection.fields || [];
                const newFields = newSection.fields || [];
                const sectionName = newSection.title || oldSection.title || 'Untitled Section';

                // Detect field additions
                if (newFields.length > oldFields.length) {
                    const addedFields = newFields.slice(oldFields.length);
                    addedFields.forEach(field => {
                        const fieldLabel = field.label || 'New field';
                        if (field.type === 'list' && field.items && field.items.length > 0) {
                            changes.push(`➕ Added "${formatText(fieldLabel)}" to "${formatText(sectionName)}" with ${field.items.length} item(s)`);
                        } else if (field.value) {
                            changes.push(`➕ Added "${formatText(fieldLabel)}" to "${formatText(sectionName)}": ${formatValue(field.value)}`);
                        } else {
                            changes.push(`➕ Added field "${formatText(fieldLabel)}" to "${formatText(sectionName)}"`);
                        }
                    });
                }

                // Detect field removals
                if (newFields.length < oldFields.length) {
                    const removedFields = oldFields.slice(newFields.length);
                    removedFields.forEach(field => {
                        const fieldLabel = field.label || 'field';
                        changes.push(`➖ Removed "${formatText(fieldLabel)}" from "${formatText(sectionName)}"`);
                    });
                }

                // Compare existing fields for value changes
                const minFieldLength = Math.min(oldFields.length, newFields.length);
                for (let j = 0; j < minFieldLength; j++) {
                    const oldField = oldFields[j];
                    const newField = newFields[j];
                    const fieldLabel = newField.label || oldField.label || 'field';

                    // Check field label change
                    if (oldField.label !== newField.label && oldField.label && newField.label) {
                        changes.push(`Renamed field from "${formatText(oldField.label)}" to "${formatText(newField.label)}" in "${formatText(sectionName)}"`);
                    }

                    // Check field value changes (for text/textarea fields)
                    if (oldField.type !== 'list' && newField.type !== 'list') {
                        const oldValue = oldField.value || '';
                        const newValue = newField.value || '';

                        if (oldValue !== newValue) {
                            const diff = getTextDiff(oldValue, newValue);
                            const diffText = formatDiff(fieldLabel, diff);
                            if (diffText) {
                                changes.push(diffText);
                            }
                        }
                    }

                    // Check list item changes
                    if (newField.type === 'list') {
                        const oldItems = (oldField.items || []).filter(item => item && item.trim());
                        const newItems = (newField.items || []).filter(item => item && item.trim());

                        if (newItems.length > oldItems.length) {
                            // Items were added
                            const addedItems = newItems.slice(oldItems.length);
                            addedItems.forEach(item => {
                                changes.push(`➕ Added to ${formatText(fieldLabel)}: ${formatValue(item, 100)}`);
                            });
                        }

                        if (newItems.length < oldItems.length) {
                            // Items were removed
                            const removedItems = oldItems.slice(newItems.length);
                            removedItems.forEach(item => {
                                changes.push(`➖ Removed from ${formatText(fieldLabel)}: ${formatValue(item, 100)}`);
                            });
                        }

                        // Check for modifications in existing items
                        const minItemLength = Math.min(oldItems.length, newItems.length);
                        for (let k = 0; k < minItemLength; k++) {
                            if (oldItems[k] !== newItems[k]) {
                                const diff = getTextDiff(oldItems[k], newItems[k]);

                                // For list items, provide more context about which item changed
                                switch (diff.type) {
                                    case 'appended':
                                        changes.push(`➕ Extended item in ${formatText(fieldLabel)}: added ${formatValue(diff.text)}`);
                                        break;
                                    case 'prepended':
                                        changes.push(`➕ Extended item in ${formatText(fieldLabel)}: added ${formatValue(diff.text)} at start`);
                                        break;
                                    case 'truncated_end':
                                        changes.push(`➖ Shortened item in ${formatText(fieldLabel)}: removed ${formatValue(diff.text)} from end`);
                                        break;
                                    case 'truncated_start':
                                        changes.push(`➖ Shortened item in ${formatText(fieldLabel)}: removed ${formatValue(diff.text)} from start`);
                                        break;
                                    case 'added_words':
                                        changes.push(`➕ Added to item in ${formatText(fieldLabel)}: ${formatValue(diff.text)}`);
                                        break;
                                    case 'removed_words':
                                        changes.push(`➖ Removed from item in ${formatText(fieldLabel)}: ${formatValue(diff.text)}`);
                                        break;
                                    case 'replaced':
                                        changes.push(`✏️ Changed item in ${formatText(fieldLabel)}: ${formatValue(diff.oldText)} → ${formatValue(diff.newText)}`);
                                        break;
                                    default:
                                        changes.push(`✏️ Modified item in ${formatText(fieldLabel)}: ${formatValue(oldItems[k], 60)} → ${formatValue(newItems[k], 60)}`);
                                }
                            }
                        }
                    }
                }
            }

            // Return all changes as a formatted list
            if (changes.length === 0) {
                return 'No changes detected';
            }

            // Return each change on its own line
            return changes.join('\n');
        }

        async function trackChange(changeType, description) {
            // Skip history tracking for public editors
            if (currentUser?.isPublicEditor) {
                return;
            }

            const { data, error } = await supabaseClient
                .from('history')
                .insert({
                    contract_id: currentContract.id,
                    user_id: currentUser.id,
                    change_type: changeType,
                    description: description,
                    snapshot: currentContract.data
                })
                .select()
                .single();

            if (error) {
                console.error('Error tracking change:', error);
                return;
            }

            // If history panel is open, manually update it with the new entry
            // (This ensures immediate local updates; realtime will handle updates from others)
            const historyPanel = document.getElementById('history-panel');
            if (historyPanel && historyPanel.classList.contains('open') && data) {
                // handleNewHistoryEntry has duplicate checking built-in
                await handleNewHistoryEntry(data);
            }
        }

        // ============================================
        // CONTRACT PREVIEW
        // ============================================

        document.getElementById('preview-btn').addEventListener('click', () => {
            collectFormData(); // Make sure we have latest data
            renderPreview();
            document.getElementById('preview-overlay').classList.add('open');
        });

        document.getElementById('close-preview-btn').addEventListener('click', () => {
            document.getElementById('preview-overlay').classList.remove('open');
        });

        function renderPreview() {
            const sections = currentContract.data?.sections || [];
            const title = currentContract.title || 'D/s Dynamic Contract';
            const date = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

            // Get party names from contract data
            const domName = currentContract.dominant_name || 'Matthew';
            const subName = currentContract.submissive_name || 'Shailah';

            let html = `
                <div class="preview-bow preview-bow-top-left">🎀</div>
                <div class="preview-bow preview-bow-top-right">🎀</div>
                <div class="preview-bow preview-bow-bottom-left">🎀</div>
                <div class="preview-bow preview-bow-bottom-right">🎀</div>
                <h1>${escapeHtml(title)}</h1>
                <p class="preview-subtitle">
                    Between Dom
                    <input type="text" class="preview-inline-name-input" value="${escapeHtml(domName)}" readonly>
                    and his sub
                    <input type="text" class="preview-inline-name-input" value="${escapeHtml(subName)}" readonly>
                </p>

                <div class="preview-terms-notice">
                    This contract establishes a Total Power Exchange (TPE) dynamic where the submissive willingly surrenders complete control and authority to the Dominant. The submissive acknowledges the Dominant's absolute authority in all matters and agrees to obey without question. All activities remain bound by established safe words and hard limits. Either party may terminate this agreement, though renegotiation requires the Dominant's approval.
                </div>
            `;

            sections.forEach((section, index) => {
                if (!section.title) return;

                // Add decorative divider before each section (except first)
                if (index > 0) {
                    html += `<div class="preview-divider">⛓️ 🎀 ⛓️</div>`;
                }

                html += `<h2>${escapeHtml(section.title)}</h2>`;

                if (!section.fields || section.fields.length === 0) {
                    html += `<p class="preview-empty">[No content yet]</p>`;
                    return;
                }

                section.fields.forEach(field => {
                    if (!field || (!field.label && !field.value && (!field.items || field.items.length === 0))) return;

                    html += `<div class="preview-field-group">`;
                    html += `<label class="preview-field-label">${escapeHtml(field.label || 'Field')}</label>`;

                    if (field.type === 'list') {
                        // Render list items as readonly inputs
                        html += `<div class="preview-list-container">`;
                        if (field.items && Array.isArray(field.items) && field.items.length > 0) {
                            field.items.forEach(item => {
                                if (item && typeof item === 'string' && item.trim()) {
                                    html += `
                                        <div class="preview-list-item">
                                            <span class="preview-list-bow">🎀</span>
                                            <input type="text" class="preview-readonly-input" value="${escapeHtml(item)}" readonly>
                                        </div>
                                    `;
                                }
                            });
                        } else {
                            html += `<p class="preview-empty">[No items]</p>`;
                        }
                        html += `</div>`;
                    } else if (field.type === 'text') {
                        // Render text input as readonly
                        const value = field.value || '';
                        html += `<input type="text" class="preview-readonly-input" value="${escapeHtml(value)}" readonly>`;
                    } else {
                        // Render textarea as readonly
                        const value = field.value || '';
                        html += `<textarea class="preview-readonly-textarea" readonly>${escapeHtml(value)}</textarea>`;
                    }

                    html += `</div>`;
                });
            });

            // Add signature section with readonly inputs
            const ownerSig = currentContract.owner_signature || '';
            const ownerDate = currentContract.owner_signature_date || '';
            const subSig = currentContract.submissive_signature || '';
            const subDate = currentContract.submissive_signature_date || '';

            const ownerDateFormatted = ownerDate ? new Date(ownerDate).toISOString().split('T')[0] : '';
            const subDateFormatted = subDate ? new Date(subDate).toISOString().split('T')[0] : '';

            html += `
                <div class="preview-divider" style="margin-top: 50px;">⛓️ 🎀 ⛓️</div>
                <div class="preview-signature-section">
                    <div class="preview-signature-box">
                        <label class="preview-field-label">Owner's Signature</label>
                        <input type="text" class="preview-readonly-input preview-signature-input" value="${escapeHtml(ownerSig)}" readonly placeholder="Not signed">
                        <input type="date" class="preview-readonly-input preview-date-input" value="${ownerDateFormatted}" readonly>
                    </div>
                    <div class="preview-signature-box">
                        <label class="preview-field-label">Submissive's Acceptance</label>
                        <input type="text" class="preview-readonly-input preview-signature-input" value="${escapeHtml(subSig)}" readonly placeholder="Not signed">
                        <input type="date" class="preview-readonly-input preview-date-input" value="${subDateFormatted}" readonly>
                    </div>
                </div>
            `;

            html += `<div class="preview-divider" style="margin-top: 50px;">⛓️ 🎀 ⛓️</div>`;
            html += `<div class="preview-date">Contract date: ${date}</div>`;

            document.getElementById('preview-content').innerHTML = html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // HISTORY TRACKING
        // ============================================

        let currentHistoryUserMap = {}; // Store user map for realtime updates
        let allHistoryItems = []; // Store all loaded history items
        let historyLimit = 50; // Items to load per batch
        let historyOffset = 0; // Current offset for pagination
        let historyFiltersSetup = false; // Flag to prevent duplicate listeners

        document.getElementById('history-btn').addEventListener('click', async () => {
            document.getElementById('history-panel').classList.add('open');
            await loadHistory();
            setupHistoryRealtime();
            if (!historyFiltersSetup) {
                setupHistoryFilters();
                historyFiltersSetup = true;
            }
        });

        document.getElementById('close-history-btn').addEventListener('click', () => {
            document.getElementById('history-panel').classList.remove('open');
            cleanupHistoryRealtime();
        });

        function setupHistoryFilters() {
            const searchInput = document.getElementById('history-search');
            const userFilter = document.getElementById('history-user-filter');
            const dateFilter = document.getElementById('history-date-filter');

            // Debounced search
            let searchTimeout;
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyHistoryFilters();
                }, 300);
            });

            userFilter.addEventListener('change', applyHistoryFilters);
            dateFilter.addEventListener('change', applyHistoryFilters);
        }

        function applyHistoryFilters() {
            const searchTerm = document.getElementById('history-search').value.toLowerCase();
            const userFilter = document.getElementById('history-user-filter').value;
            const dateFilter = document.getElementById('history-date-filter').value;

            let filteredItems = allHistoryItems.filter(item => {
                // Search filter
                if (searchTerm && !item.description.toLowerCase().includes(searchTerm)) {
                    return false;
                }

                // User filter
                if (userFilter !== 'all' && item.user_id !== userFilter) {
                    return false;
                }

                // Date filter
                if (dateFilter !== 'all') {
                    const itemDate = new Date(item.created_at);
                    const dateGroup = getDateGroup(itemDate);
                    if (dateGroup !== dateFilter) {
                        return false;
                    }
                }

                return true;
            });

            renderHistory(filteredItems, currentHistoryUserMap);
        }

        function setupHistoryRealtime() {
            // Clean up existing channel
            if (historyChannel) {
                supabaseClient.removeChannel(historyChannel);
            }

            // Subscribe to history INSERT events
            historyChannel = supabaseClient
                .channel(`history:${currentContract.id}`)
                .on(
                    'postgres_changes',
                    {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'history',
                        filter: `contract_id=eq.${currentContract.id}`
                    },
                    async (payload) => {
                        console.log('New history entry received:', payload);
                        await handleNewHistoryEntry(payload.new);
                    }
                )
                .subscribe((status) => {
                    if (status === 'SUBSCRIBED') {
                        console.log('✅ History realtime enabled');
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.warn('⚠️ History realtime connection failed:', status);
                    }
                });
        }

        function cleanupHistoryRealtime() {
            if (historyChannel) {
                supabaseClient.removeChannel(historyChannel);
                historyChannel = null;
            }
        }

        async function handleNewHistoryEntry(newEntry) {
            // Check if this entry already exists in our array (prevent duplicates)
            const existingIndex = allHistoryItems.findIndex(item => item.id === newEntry.id);
            if (existingIndex !== -1) {
                console.log('History entry already exists, skipping duplicate:', newEntry.id);
                return;
            }

            // Fetch user profile if not already in map
            if (!currentHistoryUserMap[newEntry.user_id]) {
                const { data: profile } = await supabaseClient
                    .from('user_profiles')
                    .select('id, display_name')
                    .eq('id', newEntry.user_id)
                    .single();

                if (profile) {
                    currentHistoryUserMap[profile.id] = profile.display_name;

                    // Update user filter dropdown
                    const userFilter = document.getElementById('history-user-filter');
                    const userName = profile.display_name || `User (${newEntry.user_id.substring(0, 8)}...)`;
                    const option = document.createElement('option');
                    option.value = newEntry.user_id;
                    option.textContent = userName;
                    userFilter.appendChild(option);
                }
            }

            // Add to beginning of allHistoryItems
            allHistoryItems.unshift(newEntry);

            // Re-apply current filters and re-render
            applyHistoryFilters();
        }

        function renderHistoryItem(item, userMap) {
            const date = new Date(item.created_at);
            const timeStr = date.toLocaleString();

            // Get user display name
            let userName = 'User';
            if (item.user_id === currentUser?.id) {
                userName = 'You';
            } else if (userMap[item.user_id]) {
                userName = userMap[item.user_id];
            } else {
                // Show truncated user ID as fallback
                userName = `User (${item.user_id.substring(0, 8)}...)`;
            }

            // Format multi-line descriptions
            const changes = item.description.split('\n').filter(line => line.trim());
            const changeHtml = changes.length > 1
                ? '<ul style="margin: 10px 0; padding-left: 20px; list-style: none;">' +
                  changes.map(change => `<li style="margin: 5px 0;">• ${change}</li>`).join('') +
                  '</ul>'
                : `<div style="margin: 5px 0;">${item.description}</div>`;

            return `
                <div class="history-item" data-history-id="${item.id}">
                    <div class="timestamp">${timeStr}</div>
                    <div class="change">
                        ${changeHtml}
                    </div>
                    <div style="margin-top: 5px; font-size: 0.85em; color: var(--accent-light-pink);">
                        by <span class="user">${userName}</span>
                    </div>
                    ${item.is_snapshot ? '<button class="btn btn-secondary" style="margin-top: 10px;" onclick="restoreSnapshot(\'' + item.id + '\')">Restore</button>' : ''}
                </div>
            `;
        }

        function getDateGroup(date) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const weekAgo = new Date(today);
            weekAgo.setDate(weekAgo.getDate() - 7);
            const monthAgo = new Date(today);
            monthAgo.setMonth(monthAgo.getMonth() - 1);

            const itemDate = new Date(date);
            const itemDay = new Date(itemDate.getFullYear(), itemDate.getMonth(), itemDate.getDate());

            if (itemDay.getTime() === today.getTime()) {
                return 'today';
            } else if (itemDay.getTime() === yesterday.getTime()) {
                return 'yesterday';
            } else if (itemDate >= weekAgo) {
                return 'week';
            } else if (itemDate >= monthAgo) {
                return 'month';
            } else {
                return 'older';
            }
        }

        function getDateGroupLabel(group) {
            const labels = {
                'today': '📅 Today',
                'yesterday': '📅 Yesterday',
                'week': '📅 This Week',
                'month': '📅 This Month',
                'older': '📅 Older'
            };
            return labels[group] || group;
        }

        async function loadHistory(loadMore = false) {
            if (!loadMore) {
                historyOffset = 0;
                allHistoryItems = [];
            }

            // Fetch history entries
            const { data, error } = await supabaseClient
                .from('history')
                .select('*')
                .eq('contract_id', currentContract.id)
                .order('created_at', { ascending: false })
                .range(historyOffset, historyOffset + historyLimit - 1);

            if (error) {
                console.error('Error loading history:', error);
                return;
            }

            // Add to all items if loading more, otherwise replace
            if (loadMore) {
                allHistoryItems.push(...data);
            } else {
                allHistoryItems = data;
            }

            historyOffset += data.length;

            // Show/hide load more button
            const loadMoreBtn = document.getElementById('history-load-more');
            if (data.length === historyLimit) {
                loadMoreBtn.style.display = 'block';
            } else {
                loadMoreBtn.style.display = 'none';
            }

            // Fetch user profiles for all users who made changes
            const userIds = [...new Set(allHistoryItems.map(item => item.user_id))];
            const { data: profiles } = await supabaseClient
                .from('user_profiles')
                .select('id, display_name')
                .in('id', userIds);

            // Create a map of user_id to display name and store globally for realtime updates
            currentHistoryUserMap = {};
            if (profiles) {
                profiles.forEach(profile => {
                    currentHistoryUserMap[profile.id] = profile.display_name;
                });
            }

            // Populate user filter dropdown
            const userFilter = document.getElementById('history-user-filter');
            const currentValue = userFilter.value;
            userFilter.innerHTML = '<option value="all">👥 All Users</option>';

            userIds.forEach(userId => {
                const userName = userId === currentUser?.id
                    ? 'You'
                    : (currentHistoryUserMap[userId] || `User (${userId.substring(0, 8)}...)`);
                const option = document.createElement('option');
                option.value = userId;
                option.textContent = userName;
                userFilter.appendChild(option);
            });

            userFilter.value = currentValue; // Restore previous selection

            renderHistory(allHistoryItems, currentHistoryUserMap);
        }

        window.loadMoreHistory = async function() {
            await loadHistory(true);
        };

        function renderHistory(items, userMap = {}) {
            const timeline = document.getElementById('history-timeline');

            if (items.length === 0) {
                timeline.innerHTML = '<p style="color: var(--accent-light-pink); text-align: center;">No history yet</p>';
                return;
            }

            // Group items by date
            const groups = {
                'today': [],
                'yesterday': [],
                'week': [],
                'month': [],
                'older': []
            };

            items.forEach(item => {
                const group = getDateGroup(item.created_at);
                groups[group].push(item);
            });

            // Render grouped items
            let html = '';
            ['today', 'yesterday', 'week', 'month', 'older'].forEach(groupKey => {
                if (groups[groupKey].length > 0) {
                    const groupLabel = getDateGroupLabel(groupKey);
                    const count = groups[groupKey].length;

                    html += `
                        <div class="history-date-group" onclick="toggleHistoryGroup('${groupKey}')">
                            ${groupLabel} (${count})
                            <span class="toggle-icon">▼</span>
                        </div>
                        <div class="history-group-items" id="history-group-${groupKey}">
                            ${groups[groupKey].map(item => renderHistoryItem(item, userMap)).join('')}
                        </div>
                    `;
                }
            });

            timeline.innerHTML = html;
        }

        window.toggleHistoryGroup = function(groupKey) {
            const header = event.currentTarget;
            const items = document.getElementById(`history-group-${groupKey}`);

            header.classList.toggle('collapsed');
            items.classList.toggle('collapsed');
        };

        document.getElementById('save-snapshot-btn').addEventListener('click', async () => {
            const description = prompt('Snapshot description:');
            if (!description) return;

            const { error } = await supabaseClient
                .from('history')
                .insert({
                    contract_id: currentContract.id,
                    user_id: currentUser.id,
                    change_type: 'snapshot',
                    description: `Snapshot: ${description}`,
                    snapshot: currentContract.data,
                    is_snapshot: true
                });

            if (error) {
                console.error('Error creating snapshot:', error);
                alert('Failed to create snapshot');
            } else {
                alert('Snapshot created!');
            }
        });

        window.restoreSnapshot = async function(historyId) {
            if (!confirm('Restore this version? Current changes will be saved as a snapshot.')) {
                return;
            }

            // Save current state as snapshot first
            await supabaseClient.from('history').insert({
                contract_id: currentContract.id,
                user_id: currentUser.id,
                change_type: 'snapshot',
                description: 'Auto-snapshot before restore',
                snapshot: currentContract.data,
                is_snapshot: true
            });

            // Load the snapshot
            const { data, error } = await supabaseClient
                .from('history')
                .select('snapshot')
                .eq('id', historyId)
                .single();

            if (error) {
                console.error('Error loading snapshot:', error);
                alert('Failed to restore snapshot');
                return;
            }

            // Restore the data
            currentContract.data = data.snapshot;
            await saveContract();
            renderContractEditor();
            alert('Snapshot restored!');
        };

        // ============================================
        // SHARING
        // ============================================

        document.getElementById('share-btn').addEventListener('click', async () => {
            document.getElementById('share-dialog').classList.add('open');
            await loadShares();
            await loadPublicShareStatus();
        });

        document.getElementById('cancel-share-btn').addEventListener('click', () => {
            document.getElementById('share-dialog').classList.remove('open');
        });

        document.getElementById('confirm-share-btn').addEventListener('click', async () => {
            const email = document.getElementById('share-email').value;
            const role = document.getElementById('share-role').value;

            if (!email) {
                alert('Please enter an email');
                return;
            }

            const { error } = await supabaseClient
                .from('contract_shares')
                .insert({
                    contract_id: currentContract.id,
                    shared_with_email: email,
                    role: role
                });

            if (error) {
                console.error('Error sharing contract:', error);
                alert('Failed to share contract');
                return;
            }

            document.getElementById('share-email').value = '';
            await loadShares();
            alert('Contract shared!');
        });

        async function loadShares() {
            const { data, error } = await supabaseClient
                .from('contract_shares')
                .select('*')
                .eq('contract_id', currentContract.id);

            if (error) {
                console.error('Error loading shares:', error);
                return;
            }

            const listEl = document.getElementById('shares-list');

            if (data.length === 0) {
                listEl.innerHTML = '<p style="color: var(--accent-light-pink);">Not shared yet</p>';
                return;
            }

            listEl.innerHTML = data.map(share => `
                <div class="list-item" style="margin-bottom: 10px;">
                    <span>${share.shared_with_email} (${share.role})</span>
                    <button class="remove-btn" onclick="removeShare('${share.id}')">Remove</button>
                </div>
            `).join('');
        }

        window.removeShare = async function(shareId) {
            const { error } = await supabaseClient
                .from('contract_shares')
                .delete()
                .eq('id', shareId);

            if (error) {
                console.error('Error removing share:', error);
                alert('Failed to remove share');
                return;
            }

            await loadShares();
        };

        // ============================================
        // PUBLIC SHARING
        // ============================================

        async function loadPublicShareStatus() {
            const isPublic = currentContract.is_public || false;
            const toggle = document.getElementById('public-share-toggle');
            const container = document.getElementById('public-link-container');
            const linkInput = document.getElementById('public-link');
            const roleSelect = document.getElementById('public-share-role');

            toggle.checked = isPublic;

            if (isPublic && currentContract.public_share_token) {
                container.style.display = 'block';
                const shareUrl = `${window.location.origin}${window.location.pathname}?share=${currentContract.public_share_token}`;
                linkInput.value = shareUrl;
                roleSelect.value = currentContract.public_share_role || 'viewer';
            } else {
                container.style.display = 'none';
            }
        }

        document.getElementById('public-share-toggle').addEventListener('change', async (e) => {
            const isEnabled = e.target.checked;
            const role = document.getElementById('public-share-role').value;

            if (isEnabled && !currentContract.public_share_token) {
                // Generate new token
                const token = generateShareToken();
                currentContract.public_share_token = token;
            }

            currentContract.is_public = isEnabled;
            currentContract.public_share_role = role;

            // Update database
            const { error } = await supabaseClient
                .from('contracts')
                .update({
                    is_public: isEnabled,
                    public_share_token: currentContract.public_share_token,
                    public_share_role: role
                })
                .eq('id', currentContract.id);

            if (error) {
                console.error('Error updating public share:', error);
                alert('Failed to update public sharing');
                e.target.checked = !isEnabled; // Revert
                return;
            }

            await loadPublicShareStatus();
        });

        // Update role when changed
        document.getElementById('public-share-role').addEventListener('change', async (e) => {
            const role = e.target.value;
            currentContract.public_share_role = role;

            const { error } = await supabaseClient
                .from('contracts')
                .update({ public_share_role: role })
                .eq('id', currentContract.id);

            if (error) {
                console.error('Error updating public share role:', error);
            }
        });

        document.getElementById('copy-link-btn').addEventListener('click', () => {
            const linkInput = document.getElementById('public-link');
            linkInput.select();
            navigator.clipboard.writeText(linkInput.value);

            const btn = document.getElementById('copy-link-btn');
            const originalText = btn.textContent;
            btn.textContent = '✓ Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        });

        function generateShareToken() {
            // Generate a random 32-character token
            const array = new Uint8Array(24);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode(...array))
                .replace(/\//g, '_')
                .replace(/\+/g, '-')
                .replace(/=/g, '');
        }

        // ============================================
        // STICKY HEADER ENHANCEMENT
        // ============================================

        function setupStickyHeaderEffect() {
            const editorHeader = document.querySelector('.editor-header');
            const appHeader = document.querySelector('.app-header');
            if (!editorHeader) return;

            let ticking = false;
            const appHeaderHeight = appHeader ? appHeader.offsetHeight : 70;

            function updateHeaderState() {
                const headerRect = editorHeader.getBoundingClientRect();

                // Check if the editor header is stuck (positioned at the app header height)
                // This means we've scrolled enough for it to be in its sticky position
                if (headerRect.top <= appHeaderHeight + 5) {
                    editorHeader.classList.add('scrolled');
                } else {
                    editorHeader.classList.remove('scrolled');
                }

                ticking = false;
            }

            function onScroll() {
                if (!ticking) {
                    window.requestAnimationFrame(updateHeaderState);
                    ticking = true;
                }
            }

            window.addEventListener('scroll', onScroll, { passive: true });

            // Initial check
            updateHeaderState();
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        // Initialize undo/redo system
        initUndoRedoSystem();

        // Setup sticky header enhancement
        setupStickyHeaderEffect();

        // Check authentication
        checkAuth();
    </script>
</body>
</html>